/* Generated By:JavaCC: Do not edit this line. SqlParserImpl.java */
package org.eigenbase.sql.parser.impl;

import org.eigenbase.sql.*;
import org.eigenbase.sql.parser.*;
import org.eigenbase.sql.fun.*;
import org.eigenbase.trace.EigenbaseTrace;
import org.eigenbase.util.BitString;
import org.eigenbase.util14.DateTimeUtil;
import org.eigenbase.sql.type.SqlTypeName;
import org.eigenbase.resource.*;

import java.math.*;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Iterator;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * SQL parser, generated from Parser.jj and CommonParser.jj by JavaCC.
 *
 * <p>The public wrapper for this parser is {@link SqlParser}.
 *
 * @author jhyde
 * @since Mar 18, 2003
 * @version $Id$
 */
public class SqlParserImpl extends SqlAbstractParserImpl implements SqlParserImplConstants {
    private static final Logger tracer = EigenbaseTrace.getParserTracer();

    private static Metadata metadata;

    // implement SqlAbstractParserImpl
    public SqlParseException normalizeException(Throwable ex)
    {
        try {
            if (ex instanceof ParseException) {
                ex = cleanupParseException((ParseException) ex);
            }
            return convertException(ex);
        } catch (ParseException e) {
            throw new AssertionError(e);
        }
    }

    // implement SqlAbstractParserImpl
    public Metadata getMetadata()
    {
        synchronized (SqlParserImpl.class) {
            if (metadata == null) {
                metadata = new MetadataImpl(
                    new SqlParserImpl(new java.io.StringReader("")));
            }
            return metadata;
        }
    }

    // implement SqlAbstractParserImpl
    public void setTabSize(int tabSize)
    {
        jj_input_stream.setTabSize(tabSize);
    }

  void debug_message1() throws ParseException {
    tracer.log(Level.INFO,  getToken( 0 ).image
        + " , " + getToken( 1 ).image );
  }

  final public String NonReservedKeyWord() throws ParseException {
    String kw;
    kw = CommonNonReservedKeyWord();
        {if (true) return kw;}
    throw new Error("Missing return statement in function");
  }

/**
 * Allows parser to be extended with new types of table references.  The
 * default implementation of this production is empty.
 */
  final public SqlNode ExtendedTableRef() throws ParseException {
    UnusedExtension();
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */
  final public SqlNode TableOverOpt() throws ParseException {
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/*
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */
  final public void SqlSelectKeywords(List keywords) throws ParseException {
    E();
  }

/*
 * Parses dialect-specific keywords immediately following the INSERT keyword.
 */
  final public void SqlInsertKeywords(List keywords) throws ParseException {
    E();
  }

  final public SqlNode ExtendedBuiltinFunctionCall() throws ParseException {
    UnusedExtension();
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/*
* Parse Floor/Ceil function parameters
*/
  final public SqlNode FloorCeilOptions(SqlParserPos pos, boolean floorFlag) throws ParseException {
    SqlNode node;
    node = StandardFloorCeilOptions(pos, floorFlag);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  void E() throws ParseException {
  }

  List startList(Object o) throws ParseException {
    List list = new ArrayList();
    list.add(o);
    return list;
  }

  SqlParserPos getPos() throws ParseException {
    return new SqlParserPos(
        token.beginLine,
        token.beginColumn,
        token.endLine,
        token.endColumn);
  }

  void checkQueryExpression(ExprContext exprContext) throws ParseException {
    switch (exprContext) {
    case ACCEPT_NONQUERY:
    case ACCEPT_SUBQUERY:
    case ACCEPT_CURSOR:
        throw SqlUtil.newContextException(
            getPos(),
            EigenbaseResource.instance().IllegalQueryExpression.ex());
    }
  }

  void checkNonQueryExpression(ExprContext exprContext) throws ParseException {
    if (exprContext == ExprContext.ACCEPT_QUERY) {
        throw SqlUtil.newContextException(
            getPos(),
            EigenbaseResource.instance().IllegalNonQueryExpression.ex());
    }
  }

  SqlDateLiteral parseDateLiteral(String s, SqlParserPos pos) throws ParseException {
    String dateStr = SqlParserUtil.strip(s, "'");
    Calendar cal = DateTimeUtil.parseDateFormat(
        dateStr, DateTimeUtil.DateFormatStr, DateTimeUtil.gmtZone);
    if (null == cal) {
        EigenbaseResource res = EigenbaseResource.instance();
        throw SqlUtil.newContextException(
            pos,
            res.IllegalLiteral.ex(
                "DATE",
                s,
                res.BadFormat.str(DateTimeUtil.DateFormatStr)));
    }
    return SqlLiteral.createDate(cal, pos);
  }

  SqlTimeLiteral parseTimeLiteral(String s, SqlParserPos pos) throws ParseException {
    String dateStr = SqlParserUtil.strip(s, "'");
    DateTimeUtil.PrecisionTime pt =
    DateTimeUtil.parsePrecisionDateTimeLiteral(
        dateStr, DateTimeUtil.TimeFormatStr, DateTimeUtil.gmtZone);
    if (null == pt) {
        EigenbaseResource res = EigenbaseResource.instance();
        throw SqlUtil.newContextException(
            pos,
            res.IllegalLiteral.ex(
                "TIME",
                s,
                res.BadFormat.str(DateTimeUtil.TimeFormatStr)));
    }
    return SqlLiteral.createTime(pt.getCalendar(), pt.getPrecision(), pos);
  }

  SqlTimestampLiteral parseTimestampLiteral(String s, SqlParserPos pos) throws ParseException {
    String dateStr = SqlParserUtil.strip(s, "'");
    DateTimeUtil.PrecisionTime pt =
    DateTimeUtil.parsePrecisionDateTimeLiteral(
        dateStr, DateTimeUtil.TimestampFormatStr, DateTimeUtil.gmtZone);
    if (null == pt) {
        EigenbaseResource res = EigenbaseResource.instance();
        throw SqlUtil.newContextException(
            pos,
            res.IllegalLiteral.ex(
                "TIMESTAMP",
                s,
                res.BadFormat.str(DateTimeUtil.TimestampFormatStr)));
    }
    return SqlLiteral.createTimestamp(pt.getCalendar(), pt.getPrecision(), pos);
  }

  SqlIntervalLiteral parseIntervalLiteral(SqlParserPos pos,
    int sign,
    String s,
    SqlIntervalQualifier intervalQualifier) throws ParseException, ParseException {
    String intervalStr = SqlParserUtil.strip(s, "'");

    if ("".equals(intervalStr)) {
        EigenbaseResource res = EigenbaseResource.instance();
        String msg = res.IllegalIntervalLiteral.str(
            s + " " + intervalQualifier.toString(), pos.toString());
        throw new ParseException(msg);
    }
    return SqlLiteral.createInterval(sign, intervalStr, intervalQualifier, pos);
  }

  SqlParseException convertException(Throwable ex) throws ParseException {
    if (ex instanceof SqlParseException) {
        return (SqlParseException) ex;
    }
    SqlParserPos pos = null;
    int[][] expectedTokenSequences = null;
    String[] tokenImage = null;
    if (ex instanceof ParseException) {
        ParseException pex = (ParseException) ex;
        expectedTokenSequences = pex.expectedTokenSequences;
        tokenImage = pex.tokenImage;
        if (pex.currentToken != null) {
            final Token token = pex.currentToken.next;
            pos = new SqlParserPos(
                token.beginLine,
                token.beginColumn,
                token.endLine,
                token.endColumn);
        }
    } else if (ex instanceof TokenMgrError) {
        TokenMgrError tme = (TokenMgrError) ex;
        expectedTokenSequences = null;
        tokenImage = null;
        // Example:
        //    Lexical error at line 3, column 24.  Encountered "#" after "a".
        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
            "(?s)Lexical error at line ([0-9]+), column ([0-9]+).*");
        java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage());
        if (matcher.matches()) {
            int line = Integer.parseInt(matcher.group(1));
            int column = Integer.parseInt(matcher.group(2));
            pos = new SqlParserPos(line, column, line, column);
        }
    } else if (ex instanceof org.eigenbase.util.EigenbaseContextException) {
        // EigenbaseContextException is the standard wrapper for exceptions
        // produced by the validator, but in the parser, the standard is
        // SqlParseException; so, strip it away. In case you were wondering,
        // the EigenbaseContextException appears because the parser
        // occasionally calls into validator-style code such as
        // SqlSpecialOperator.reduceExpr.
        org.eigenbase.util.EigenbaseContextException ece =
            (org.eigenbase.util.EigenbaseContextException) ex;
        pos = new SqlParserPos(
            ece.getPosLine(),
            ece.getPosColumn(),
            ece.getEndPosLine(),
            ece.getEndPosColumn());
        ex = ece.getCause();
    }

    return new SqlParseException(
        ex.getMessage(), pos, expectedTokenSequences, tokenImage, ex);
  }

  ParseException cleanupParseException(ParseException ex) throws ParseException {
    if (ex.expectedTokenSequences == null) {
        return ex;
    }
    int iIdentifier = java.util.Arrays.asList(ex.tokenImage).indexOf("<IDENTIFIER>");

    // Find all sequences in the error which contain identifier. For
    // example,
    //       {<IDENTIFIER>}
    //       {A}
    //       {B, C}
    //       {D, <IDENTIFIER>}
    //       {D, A}
    //       {D, B}
    //
    // would yield
    //       {}
    //       {D}
    boolean id = false;
    ArrayList prefixList = new ArrayList();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int[] seq = ex.expectedTokenSequences[i];
        int j = seq.length - 1;
        int i1 = seq[j];
        if (i1 == iIdentifier) {
            int[] prefix = new int[j];
            System.arraycopy(seq, 0, prefix, 0, j);
            prefixList.add(prefix);
        }
    }

    if (prefixList.isEmpty()) {
        return ex;
    }

    int[][] prefixes = (int[][])
        prefixList.toArray(new int[prefixList.size()][]);

    // Since <IDENTIFIER> was one of the possible productions,
    // we know that the parser will also have included all
    // of the non-reserved keywords (which are treated as
    // identifiers in non-keyword contexts).  So, now we need
    // to clean those out, since they're totally irrelevant.

    List list = new ArrayList();
    Metadata metadata = getMetadata();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int [] seq = ex.expectedTokenSequences[i];
        String tokenImage = ex.tokenImage[seq[seq.length - 1]];
        String token = SqlParserUtil.getTokenVal(tokenImage);
        if (token == null  || !metadata.isNonReservedKeyword(token)) {
            list.add(seq);
            continue;
        }
        boolean match = matchesPrefix(seq, prefixes);
        if (!match) {
            list.add(seq);
        }
    }

    ex.expectedTokenSequences =
        (int [][]) list.toArray(new int [list.size()][]);
    return ex;
  }

  boolean matchesPrefix(int[] seq, int[][] prefixes) throws ParseException {
    nextPrefix:
    for (int j = 0; j < prefixes.length; j++) {
        int[] prefix = prefixes[j];
        if (seq.length == prefix.length + 1) {
            for (int k = 0; k < prefix.length; k++) {
                if (prefix[k] != seq[k]) {
                    continue nextPrefix;
                }
            }
            return true;
        }
    }
    return false;
  }

/*****************************************
 * Syntactical Descriptions              *
 *****************************************/

/**
 * Parses either a row expression or a query expression with an optional
 * ORDER BY.
 */
  final public SqlNode OrderedQueryOrExpr(ExprContext exprContext) throws ParseException {
    SqlNode e;
    SqlNodeList orderBy;
    SqlParserPos pos;
    e = QueryOrExpr(exprContext);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      // use the syntactic type of the expression we just parsed
              // to decide whether ORDER BY makes sense
              orderBy = OrderBy(e.isA(SqlKind.QUERY));
            pos = getPos();
            e = SqlStdOperatorTable.orderByOperator.createCall(pos, e, orderBy);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a leaf in a query expression (SELECT, VALUES or TABLE).
 */
  final public SqlNode LeafQuery(ExprContext exprContext) throws ParseException {
    SqlNode e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
        // ensure a query is legal in this context
        checkQueryExpression(exprContext);
      e = SqlSelect();
        {if (true) return e;}
      break;
    case VALUES:
      e = TableConstructor();
        {if (true) return e;}
      break;
    case TABLE:
      e = ExplicitTable(getPos());
        {if (true) return e;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a parenthesized query or single row expression.
 */
  final public SqlNode ParenthesizedExpression(ExprContext exprContext) throws ParseException {
    SqlNode e;
    jj_consume_token(LPAREN);
        // we've now seen left paren, so queries inside should
        // be allowed as subqueries
        switch (exprContext) {
        case ACCEPT_SUBQUERY:
            exprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            exprContext = ExprContext.ACCEPT_ALL;
            break;
        }
    e = OrderedQueryOrExpr(exprContext);
    jj_consume_token(RPAREN);
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a parenthesized query or comma-list of row expressions.
 *
 *<p>
 *
 * REVIEW jvs 8-Feb-2004: There's a small hole in this production.  It can be
 * used to construct something like
 *
 * <code>WHERE x IN (select count(*) from t where c=d,5)</code>,
 *
 * which should be illegal.  The above is interpreted as equivalent to
 *
 * <code>WHERE x IN ((select count(*) from t where c=d),5)</code>,
 *
 * which is a legal use of a subquery.  The only way to fix the hole is to be
 * able to remember whether a subexpression was parenthesized or not, which
 * means preserving parentheses in the SqlNode tree.  This is probably
 * desirable anyway for use in purely syntactic parsing applications (e.g. SQL
 * pretty-printer).  However, if this is done, it's important to also make
 * isA() on the paren node call down to its operand so that we can
 * always correctly discriminate a query from a row expression.
 */
  final public SqlNodeList ParenthesizedQueryOrCommaList(ExprContext exprContext) throws ParseException {
    SqlNode e;
    List list;
    ExprContext firstExprContext = exprContext;
    SqlParserPos pos;
    jj_consume_token(LPAREN);
        // we've now seen left paren, so a query by itself should
        // be interpreted as a subquery
        pos = getPos();
        switch (exprContext) {
        case ACCEPT_SUBQUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        }
    e = OrderedQueryOrExpr(firstExprContext);
        list = startList(e);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      jj_consume_token(COMMA);
            // a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
      e = Expression(exprContext);
            list.add(e);
    }
    jj_consume_token(RPAREN);
        {if (true) return new SqlNodeList(list, pos.plus(getPos()));}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses function parameter lists including DISTINCT keyword recognition
 *
 *<p>
 *
 * This is pretty much the same as ParenthesizedQueryOrCommaList but allows the
 * DISTINCT keyword to follow the left paren and not be followed by a comma.
 */
  final public List FunctionParameterList(ExprContext exprContext) throws ParseException {
    SqlNode e = null;
    List list = new ArrayList();
    ExprContext firstExprContext = exprContext;
    jj_consume_token(LPAREN);
        // we've now seen left paren, so queries inside should
        // be allowed as subqueries
        switch (exprContext) {
        case ACCEPT_SUBQUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
    case DISTINCT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
            e = SqlLiteral.createSymbol(SqlSelectKeyword.Distinct, getPos());
        break;
      case ALL:
        jj_consume_token(ALL);
            e = SqlLiteral.createSymbol(SqlSelectKeyword.All, getPos());
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
       list.add(e);
    e = OrderedQueryOrExpr(firstExprContext);
        if (e != null) {
            list.add(e);
        }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
            // a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
      e = Expression(exprContext);
            list.add(e);
    }
    jj_consume_token(RPAREN);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a query (SELECT, UNION, INTERSECT, EXCEPT, VALUES, TABLE) followed by
 * the end-of-file symbol.
 */
  final public SqlNode SqlQueryEof() throws ParseException {
    SqlNode query;
    query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
    jj_consume_token(0);
      {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an SQL statement.
 */
  final public SqlNode SqlStmt() throws ParseException {
    SqlNode stmt;
    if (jj_2_1(1)) {
      stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPLAIN:
        stmt = SqlExplain();
        break;
      case INSERT:
        stmt = SqlInsert();
        break;
      case DELETE:
        stmt = SqlDelete();
        break;
      case UPDATE:
        stmt = SqlUpdate();
        break;
      case MERGE:
        stmt = SqlMerge();
        break;
      case CALL:
        stmt = SqlProcedureCall();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 */
  final public SqlNode SqlStmtEof() throws ParseException {
    SqlNode stmt;
    stmt = SqlStmt();
    jj_consume_token(0);
        {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a leaf SELECT expression without ORDER BY.
 */
  final public SqlSelect SqlSelect() throws ParseException {
    List keywords = new ArrayList();
    List selectList;
    SqlNode fromClause;
    SqlNode where;
    SqlNode groupBy;
    SqlNode having;
    SqlNodeList windowDecls;
    SqlParserPos pos;
    SqlParserPos selectListPos;
    SqlNode selectItem;
    jj_consume_token(SELECT);
        pos = getPos();
    SqlSelectKeywords(keywords);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTINCT:
      jj_consume_token(DISTINCT);
            keywords.add(
                SqlLiteral.createSymbol(SqlSelectKeyword.Distinct, getPos()));
      break;
    case ALL:
      jj_consume_token(ALL);
            keywords.add(
                SqlLiteral.createSymbol(SqlSelectKeyword.All, getPos()));
      break;
    default:
      jj_la1[7] = jj_gen;
      E();
    }
    selectList = SelectList();
    jj_consume_token(FROM);
    fromClause = FromClause();
    where = WhereOpt();
    groupBy = GroupByOpt();
    having = HavingOpt();
    windowDecls = WindowOpt();
        selectItem = (SqlNode)selectList.get(0);
        selectListPos = selectItem.getParserPosition();
        {if (true) return SqlStdOperatorTable.selectOperator.createCall(
            new SqlNodeList(keywords, pos),
            new SqlNodeList(selectList, selectListPos.plusAll(selectList)),
            fromClause, where, groupBy, having, windowDecls, null,
            pos.plus(getPos()));}
    throw new Error("Missing return statement in function");
  }

/*
 * Abstract production:
 *
 *    void SqlSelectKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */

/**
 * Parses an EXPLAIN PLAN statement.
 */
  final public SqlNode SqlExplain() throws ParseException {
    SqlNode stmt;
    SqlExplainLevel detailLevel = SqlExplainLevel.EXPPLAN_ATTRIBUTES;
    SqlExplain.Depth depth;
    SqlParserPos pos;
    boolean asXml;
    jj_consume_token(EXPLAIN);
    jj_consume_token(PLAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCLUDING:
    case INCLUDING:
      detailLevel = ExplainDetailLevel();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    depth = ExplainDepth();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      jj_consume_token(XML);
                     asXml = true;
      break;
    default:
      jj_la1[9] = jj_gen;
            asXml = false;
    }
    jj_consume_token(FOR);
    if (jj_2_2(1)) {
      stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INSERT:
        stmt = SqlInsert();
        break;
      case DELETE:
        stmt = SqlDelete();
        break;
      case UPDATE:
        stmt = SqlUpdate();
        break;
      case MERGE:
        stmt = SqlMerge();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        pos = getPos();
        {if (true) return new SqlExplain(
            SqlStdOperatorTable.explainOperator,
            stmt,
            SqlLiteral.createSymbol(detailLevel, SqlParserPos.ZERO),
            SqlLiteral.createSymbol(depth, SqlParserPos.ZERO),
            SqlLiteral.createBoolean(asXml, SqlParserPos.ZERO),
            nDynamicParams,
            pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses WITH TYPE | WITH IMPLEMENTATION | WITHOUT IMPLEMENTATION modifier for
 * EXPLAIN PLAN.
 */
  final public SqlExplain.Depth ExplainDepth() throws ParseException {
    if (jj_2_3(2)) {
      jj_consume_token(WITH);
      jj_consume_token(TYPE);
            {if (true) return SqlExplain.Depth.Type;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WITH:
        jj_consume_token(WITH);
        jj_consume_token(IMPLEMENTATION);
            {if (true) return SqlExplain.Depth.Physical;}
        break;
      case WITHOUT:
        jj_consume_token(WITHOUT);
        jj_consume_token(IMPLEMENTATION);
            {if (true) return SqlExplain.Depth.Logical;}
        break;
      default:
        jj_la1[11] = jj_gen;
            {if (true) return SqlExplain.Depth.Physical;}
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses INCLUDING ALL ATTRIBUTES modifier for EXPLAIN PLAN.
 */
  final public SqlExplainLevel ExplainDetailLevel() throws ParseException {
    SqlExplainLevel level = SqlExplainLevel.EXPPLAN_ATTRIBUTES;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCLUDING:
      jj_consume_token(EXCLUDING);
      jj_consume_token(ATTRIBUTES);
            level = SqlExplainLevel.NO_ATTRIBUTES;
      break;
    case INCLUDING:
      jj_consume_token(INCLUDING);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
        jj_consume_token(ALL);
                  level = SqlExplainLevel.ALL_ATTRIBUTES;
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      jj_consume_token(ATTRIBUTES);

      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return level;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a CALL statement.
 */
  final public SqlNode SqlProcedureCall() throws ParseException {
    SqlParserPos callPos;
    SqlNode routineCall;
    jj_consume_token(CALL);
        callPos = getPos();
    routineCall = NamedRoutineCall(SqlFunctionCategory.UserDefinedProcedure,
            ExprContext.ACCEPT_SUBQUERY);
        {if (true) return SqlStdOperatorTable.procedureCallOperator.createCall(
            callPos, routineCall);}
    throw new Error("Missing return statement in function");
  }

  final public SqlNode NamedRoutineCall(SqlFunctionCategory routineType,
    ExprContext exprContext) throws ParseException {
    SqlIdentifier name;
    SqlNodeList args;
    SqlParserPos pos;
    name = CompoundIdentifier();
        pos = getPos();
    if (jj_2_4(2)) {
      jj_consume_token(LPAREN);
          pos = getPos();
      jj_consume_token(RPAREN);
          pos = pos.plus(getPos()); args = new SqlNodeList(pos);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        args = ParenthesizedQueryOrCommaList(exprContext);
          pos = pos.plus(getPos());
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        SqlNode function = createCall(
            name, pos, routineType, null, SqlParserUtil.toNodeArray(args));
        {if (true) return function;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an INSERT statement.
 */
  final public SqlNode SqlInsert() throws ParseException {
    List keywords = new ArrayList();
    SqlIdentifier table;
    SqlNode source;
    List columnList = null;
    SqlParserPos pos;
    SqlParserPos columnListPos = null;
    jj_consume_token(INSERT);
    SqlInsertKeywords(keywords);
    jj_consume_token(INTO);
    table = CompoundIdentifier();
        pos = getPos();
    if (jj_2_5(2)) {
      jj_consume_token(LPAREN);
      columnList = SimpleIdentifierCommaList();
            columnListPos = getPos();
      jj_consume_token(RPAREN);
    } else {
      ;
    }
    source = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
        {if (true) return new SqlInsert(
            SqlStdOperatorTable.insertOperator,
            new SqlNodeList(keywords, pos),
            table,
            source,
            (columnList != null)
            ? new SqlNodeList(columnList, columnListPos) : null,
            pos);}
    throw new Error("Missing return statement in function");
  }

/*
 * Abstract production:
 *
 *    void SqlInsertKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the INSERT keyword.
 */

/**
 * Parses a DELETE statement.
 */
  final public SqlNode SqlDelete() throws ParseException {
    SqlIdentifier table;
    SqlIdentifier alias = null;
    SqlNode condition;
    SqlParserPos pos;
    jj_consume_token(DELETE);
        pos = getPos();
    jj_consume_token(FROM);
    table = CompoundIdentifier();

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case AS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      alias = SimpleIdentifier();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    condition = WhereOpt();
        {if (true) return new SqlDelete(
            SqlStdOperatorTable.deleteOperator,
            table,
            condition,
            alias,
            pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an UPDATE statement.
 */
  final public SqlNode SqlUpdate() throws ParseException {
    SqlIdentifier table;
    SqlIdentifier alias = null;
    SqlNode condition;
    SqlNodeList sourceExpressionList;
    SqlNodeList targetColumnList;
    SqlIdentifier id;
    SqlNode exp;
    SqlParserPos pos;
    jj_consume_token(UPDATE);
    table = CompoundIdentifier();
        pos = getPos();
        targetColumnList = new SqlNodeList(pos);
        sourceExpressionList = new SqlNodeList(pos);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case AS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      alias = SimpleIdentifier();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(SET);
    id = SimpleIdentifier();
        targetColumnList.add(id);
    jj_consume_token(EQ);
    exp = Expression(ExprContext.ACCEPT_SUBQUERY);
        // TODO:  support DEFAULT also
        sourceExpressionList.add(exp);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      id = SimpleIdentifier();
            targetColumnList.add(id);
      jj_consume_token(EQ);
      exp = Expression(ExprContext.ACCEPT_SUBQUERY);
            sourceExpressionList.add(exp);
    }
    condition = WhereOpt();
        {if (true) return new SqlUpdate(
            SqlStdOperatorTable.updateOperator,
            table,
            targetColumnList,
            sourceExpressionList,
            condition,
            alias,
            pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a MERGE statement.
 */
  final public SqlNode SqlMerge() throws ParseException {
    SqlIdentifier table;
    SqlIdentifier alias = null;
    SqlNode sourceTableRef;
    SqlNode condition;
    SqlNode updateCall = null;
    SqlNode insertCall = null;
    SqlParserPos mergePos;
    jj_consume_token(MERGE);
    jj_consume_token(INTO);
    table = CompoundIdentifier();
        mergePos = getPos();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case AS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      alias = SimpleIdentifier();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    jj_consume_token(USING);
    sourceTableRef = TableRef();
    jj_consume_token(ON);
    condition = Expression(ExprContext.ACCEPT_SUBQUERY);
    if (jj_2_6(2)) {
      updateCall = WhenMatchedClause(table, alias);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHEN:
        insertCall = WhenNotMatchedClause(table);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHEN:
        insertCall = WhenNotMatchedClause(table);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return new SqlMerge(
            SqlStdOperatorTable.mergeOperator,
            table,
            condition,
            sourceTableRef,
            updateCall,
            insertCall,
            alias,
            mergePos);}
    throw new Error("Missing return statement in function");
  }

  final public SqlNode WhenMatchedClause(SqlIdentifier table, SqlIdentifier alias) throws ParseException {
    SqlIdentifier id;
    SqlParserPos pos;
    SqlNodeList updateColumnList;
    SqlNode exp;
    SqlNodeList updateExprList;
    jj_consume_token(WHEN);
    jj_consume_token(MATCHED);
    jj_consume_token(THEN);
    jj_consume_token(UPDATE);
    jj_consume_token(SET);
    id = SimpleIdentifier();
        pos = getPos();
        updateColumnList = new SqlNodeList(pos);
        updateExprList = new SqlNodeList(pos);
        updateColumnList.add(id);
    jj_consume_token(EQ);
    exp = Expression(ExprContext.ACCEPT_SUBQUERY);
        updateExprList.add(exp);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      id = SimpleIdentifier();
            updateColumnList.add(id);
      jj_consume_token(EQ);
      exp = Expression(ExprContext.ACCEPT_SUBQUERY);
            updateExprList.add(exp);
    }
        {if (true) return new SqlUpdate(
            SqlStdOperatorTable.updateOperator,
            table,
            updateColumnList,
            updateExprList,
            null,
            alias,
            pos);}
    throw new Error("Missing return statement in function");
  }

  final public SqlNode WhenNotMatchedClause(SqlIdentifier table) throws ParseException {
    SqlParserPos pos, insertPos, columnListPos = null;
    List keywords = new ArrayList();
    List insertColumnList = null;
    SqlNode rowConstructor;
    SqlNode insertValues;
    jj_consume_token(WHEN);
    jj_consume_token(NOT);
    jj_consume_token(MATCHED);
    jj_consume_token(THEN);
    jj_consume_token(INSERT);
        insertPos = getPos();
    SqlInsertKeywords(keywords);
    if (jj_2_7(2)) {
      jj_consume_token(LPAREN);
      insertColumnList = SimpleIdentifierCommaList();
            columnListPos = getPos();
      jj_consume_token(RPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    jj_consume_token(VALUES);
               pos = getPos();
    rowConstructor = RowConstructor();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
        // TODO zfong 5/26/06: note that extra parentheses are accepted above
        // around the VALUES clause as a hack for unparse, but this is
        // actually invalid SQL; should fix unparse
        insertValues = SqlStdOperatorTable.valuesOperator.createCall(
            pos.plus(rowConstructor.getParserPosition()),
            rowConstructor);
        {if (true) return new SqlInsert(
            SqlStdOperatorTable.insertOperator,
            new SqlNodeList(keywords, insertPos),
            table,
            insertValues,
            (insertColumnList != null)
                ? new SqlNodeList(insertColumnList, columnListPos) : null,
            insertPos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the select list of a SELECT statement.
 */
  final public List SelectList() throws ParseException {
    List list = new ArrayList();
    SqlNode item;
    item = SelectItem();
                         list.add(item);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      item = SelectItem();
                                   list.add(item);
    }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one item in a select list.
 */
  final public SqlNode SelectItem() throws ParseException {
    SqlNode e;
    SqlIdentifier id;
    SqlParserPos pos;
    e = SelectExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case AS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      id = SimpleIdentifier();
            pos = e.getParserPosition().plus(getPos());
            e = SqlStdOperatorTable.asOperator.createCall(pos, e, id);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one unaliased expression in a select list.
 */
  final public SqlNode SelectExpression() throws ParseException {
    SqlNode e;
    String id;
    SqlParserPos pos, starPos;
    if (jj_2_8(3)) {
      id = Identifier();
                        pos = getPos();
      jj_consume_token(DOT);
      jj_consume_token(STAR);
        starPos = getPos();
        {if (true) return new SqlIdentifier(
            new String[] {id, "*"},
            null,
            pos.plus(starPos),
            new SqlParserPos[] {pos, starPos});}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        pos = getPos();
        {if (true) return new SqlIdentifier("*", pos);}
        break;
      default:
        jj_la1[30] = jj_gen;
        if (jj_2_9(1)) {
          e = Expression(ExprContext.ACCEPT_SUBQUERY);
        {if (true) return e;}
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

// TODO jvs 15-Nov-2003:  SQL standard allows parentheses in the FROM list for
// building up non-linear join trees (e.g. OUTER JOIN two tables, and then INNER
// JOIN the result).  Also note that aliases on parenthesized FROM expressions
// "hide" all table names inside the parentheses (without aliases, they're
// visible).
//
// We allow CROSS JOIN to have a join condition, even though that is not valid
// SQL; the validator will catch it.
/**
 * Parses the FROM clause a SELECT.
 */
  final public SqlNode FromClause() throws ParseException {
    SqlNode e, e2, condition;
    boolean isNatural;
    SqlJoinOperator.JoinType joinType;
    List list;
    SqlParserPos pos;
    SqlParserPos joinTypePos;
    SqlParserPos naturalPos;
    e = TableRef();
    label_6:
    while (true) {
      if (jj_2_10(1)) {
        ;
      } else {
        break label_6;
      }
      if (jj_2_11(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NATURAL:
          jj_consume_token(NATURAL);
                       isNatural = true;
          break;
        default:
          jj_la1[31] = jj_gen;
             isNatural = false;
        }
            naturalPos = getPos();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case JOIN:
          jj_consume_token(JOIN);
             joinType = SqlJoinOperator.JoinType.Inner;
          break;
        case INNER:
          jj_consume_token(INNER);
          jj_consume_token(JOIN);
             joinType = SqlJoinOperator.JoinType.Inner;
          break;
        case LEFT:
          jj_consume_token(LEFT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OUTER:
            jj_consume_token(OUTER);
            break;
          default:
            jj_la1[32] = jj_gen;
            ;
          }
          jj_consume_token(JOIN);
             joinType = SqlJoinOperator.JoinType.Left;
          break;
        case RIGHT:
          jj_consume_token(RIGHT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OUTER:
            jj_consume_token(OUTER);
            break;
          default:
            jj_la1[33] = jj_gen;
            ;
          }
          jj_consume_token(JOIN);
             joinType = SqlJoinOperator.JoinType.Right;
          break;
        case FULL:
          jj_consume_token(FULL);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OUTER:
            jj_consume_token(OUTER);
            break;
          default:
            jj_la1[34] = jj_gen;
            ;
          }
          jj_consume_token(JOIN);
             joinType = SqlJoinOperator.JoinType.Full;
          break;
        case CROSS:
          jj_consume_token(CROSS);
          jj_consume_token(JOIN);
             joinType = SqlJoinOperator.JoinType.Cross;
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
            joinTypePos = getPos();
        e2 = TableRef();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ON:
          jj_consume_token(ON);
                   pos = getPos();
          condition = Expression(ExprContext.ACCEPT_SUBQUERY);
                SqlParserPos onPos = pos.plus(getPos());
                e = SqlStdOperatorTable.joinOperator.createCall(
                    e,
                    SqlLiteral.createBoolean(isNatural, naturalPos),
                    SqlLiteral.createSymbol(joinType, joinTypePos),
                    e2,
                    SqlLiteral.createSymbol(
                        SqlJoinOperator.ConditionType.On, onPos),
                    condition,
                    joinTypePos);
          break;
        case USING:
          jj_consume_token(USING);
                      pos = getPos();
          jj_consume_token(LPAREN);
          list = SimpleIdentifierCommaList();
          jj_consume_token(RPAREN);
                SqlParserPos usingPos = pos.plus(getPos());
                e = SqlStdOperatorTable.joinOperator.createCall(
                    e,
                    SqlLiteral.createBoolean(isNatural, naturalPos),
                    SqlLiteral.createSymbol(joinType, joinTypePos),
                    e2,
                    SqlLiteral.createSymbol(
                        SqlJoinOperator.ConditionType.Using, usingPos),
                    new SqlNodeList(list, usingPos),
                    joinTypePos);
          break;
        default:
          jj_la1[36] = jj_gen;
                e = SqlStdOperatorTable.joinOperator.createCall(
                    e,
                    SqlLiteral.createBoolean(isNatural, naturalPos),
                    SqlLiteral.createSymbol(joinType, joinTypePos),
                    e2,
                    SqlLiteral.createSymbol(
                        SqlJoinOperator.ConditionType.None, joinTypePos),
                    null,
                    joinTypePos);
        }
      } else if (true) {
        jj_consume_token(COMMA);
                  pos = getPos();
        e2 = TableRef();
            e = SqlStdOperatorTable.joinOperator.createCall(
                e,
                SqlLiteral.createBoolean(false, pos),
                SqlLiteral.createSymbol(SqlJoinOperator.JoinType.Comma,
                    SqlParserPos.ZERO),
                e2,
                SqlLiteral.createSymbol(
                    SqlJoinOperator.ConditionType.None, SqlParserPos.ZERO),
                null,
                pos);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

// TODO jvs 15-Nov-2003: SQL standard allows column aliases on table
// references, e.g. DEPTS AS D1(DEPTNO1,DNAME1); I guess this is syntactic
// sugar to make it easier for query writers to conform to the column name
// uniqueness rules without requiring them to write a nested SELECT, but it
// seems pretty useless for non-trivial tables, since you have to supply names
// for ALL columns at once.
/**
 * Parses a table reference in a FROM clause.
 */
  final public SqlNode TableRef() throws ParseException {
    SqlNode tableRef;
    SqlNode over;
    String alias;
    SqlParserPos pos;
    SqlNodeList args;
    SqlNode sample;
    boolean isBernoulli;
    SqlNumericLiteral samplePercentage;
    boolean isRepeatable = false;
    int repeatableSeed = 0;
    List<SqlNode> columnAliasList = null;
    if (jj_2_12(2)) {
      tableRef = CompoundIdentifier();
      over = TableOverOpt();
            if (over != null) {
                pos = getPos();
                tableRef = SqlStdOperatorTable.overOperator.createCall(
                    pos, tableRef, over);
            }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LATERAL:
      case LPAREN:
          boolean isLateral = false;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LATERAL:
          jj_consume_token(LATERAL);
                     isLateral = true;
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        tableRef = ParenthesizedExpression(ExprContext.ACCEPT_QUERY);
        over = TableOverOpt();
            if (over != null) {
                pos = getPos();
                tableRef = SqlStdOperatorTable.overOperator.createCall(
                    pos, tableRef, over);
            }
            if (isLateral) {
                tableRef = SqlStdOperatorTable.lateralOperator.createCall(
                    getPos(), tableRef);
            }
        break;
      case UNNEST:
        jj_consume_token(UNNEST);
                   pos = getPos();
        args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUBQUERY);
            tableRef =
                SqlStdOperatorTable.unnestOperator.createCall(
                    pos.plus(getPos()), args.toArray());
        break;
      case TABLE:
        jj_consume_token(TABLE);
                  pos = getPos();
        jj_consume_token(LPAREN);
        tableRef = TableFunctionCall(pos);
        jj_consume_token(RPAREN);

        break;
      default:
        jj_la1[38] = jj_gen;
        if (jj_2_13(1)) {
          tableRef = ExtendedTableRef();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case AS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      alias = Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        columnAliasList = SimpleIdentifierCommaList();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
            pos = getPos();
            if (columnAliasList == null) {
                tableRef = SqlStdOperatorTable.asOperator.createCall(
                    pos, tableRef, new SqlIdentifier(alias, pos));
            } else {
                List<SqlNode> idList = new ArrayList<SqlNode>();
                idList.add(tableRef);
                idList.add(new SqlIdentifier(alias, pos));
                idList.addAll(columnAliasList);
                tableRef = SqlStdOperatorTable.asOperator.createCall(
                    pos, idList);
            }
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLESAMPLE:
      jj_consume_token(TABLESAMPLE);
                        pos = getPos();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUBSTITUTE:
        jj_consume_token(SUBSTITUTE);
        jj_consume_token(LPAREN);
        sample = StringLiteral();
        jj_consume_token(RPAREN);
                String sampleName = SqlLiteral.stringValue(sample);
                SqlSampleSpec sampleSpec = SqlSampleSpec.createNamed(sampleName);
                SqlLiteral sampleLiteral = SqlLiteral.createSample(sampleSpec, pos);
                tableRef = SqlStdOperatorTable.sampleFunction.createCall(
                    pos.plus(getPos()), tableRef, sampleLiteral);
        break;
      case BERNOULLI:
      case SYSTEM:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BERNOULLI:
          jj_consume_token(BERNOULLI);
                    isBernoulli = true;
          break;
        case SYSTEM:
          jj_consume_token(SYSTEM);
                    isBernoulli = false;
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(LPAREN);
        samplePercentage = UnsignedNumericLiteral();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case REPEATABLE:
          jj_consume_token(REPEATABLE);
          jj_consume_token(LPAREN);
          repeatableSeed = IntLiteral();
          jj_consume_token(RPAREN);
                    isRepeatable = true;
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
                final BigDecimal ONE_HUNDRED = BigDecimal.valueOf(100L);
                BigDecimal rate = samplePercentage.bigDecimalValue();
                if (rate.compareTo(BigDecimal.ZERO) < 0
                    || rate.compareTo(ONE_HUNDRED) > 0)
                {
                    {if (true) throw new ParseException(
                        EigenbaseResource.instance().InvalidSampleSize.str());}
                }

                // Treat TABLESAMPLE(0) and TABLESAMPLE(100) as no table
                // sampling at all.  Not strictly correct: TABLESAMPLE(0)
                // should produce no output, but it simplifies implementation
                // to know that some amount of sampling will occur.
                // In practice values less than ~1E-43% are treated as 0.0 and
                // values greater than ~99.999997% are treated as 1.0
                float fRate = rate.divide(ONE_HUNDRED).floatValue();
                if (fRate > 0.0f && fRate < 1.0f) {
                    SqlSampleSpec tableSampleSpec =
                    isRepeatable
                        ? SqlSampleSpec.createTableSample(
                            isBernoulli, fRate, repeatableSeed)
                        : SqlSampleSpec.createTableSample(isBernoulli, fRate);

                    SqlLiteral tableSampleLiteral =
                        SqlLiteral.createSample(tableSampleSpec, pos);
                    tableRef = SqlStdOperatorTable.sampleFunction.createCall(
                        pos.plus(getPos()), tableRef, tableSampleLiteral);
                }
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
        {if (true) return tableRef;}
    throw new Error("Missing return statement in function");
  }

  final public SqlNode TableFunctionCall(SqlParserPos pos) throws ParseException {
    SqlNode call;
    SqlFunctionCategory funcType =
        SqlFunctionCategory.UserDefinedFunction;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SPECIFIC:
      jj_consume_token(SPECIFIC);
            funcType = SqlFunctionCategory.UserDefinedSpecificFunction;
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }

    call = NamedRoutineCall(funcType, ExprContext.ACCEPT_CURSOR);
        {if (true) return SqlStdOperatorTable.collectionTableOperator.createCall(
            pos, call);}

        {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

/**
 * Abstract production:
 *    SqlNode ExtendedTableRef()
 *
 * Allows parser to be extended with new types of table references.  The
 * default implementation of this production is empty.
 */

/*
 * Abstract production:
 *
 *    SqlNode TableOverOpt()
 *
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */

/**
 * Parses an explicit TABLE t reference.
 */
  final public SqlNode ExplicitTable(SqlParserPos pos) throws ParseException {
    SqlNode tableRef;
    jj_consume_token(TABLE);
    tableRef = CompoundIdentifier();
        {if (true) return SqlStdOperatorTable.explicitTableOperator.createCall(
            pos, tableRef);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a VALUES leaf query expression.
 */
  final public SqlNode TableConstructor() throws ParseException {
    SqlNodeList rowConstructorList;
    SqlParserPos pos;
    jj_consume_token(VALUES);
        pos = getPos();
    rowConstructorList = RowConstructorList(pos);
        {if (true) return SqlStdOperatorTable.valuesOperator.createCall(
            pos.plus(getPos()), rowConstructorList.toArray());}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one or more rows in a VALUES expression.
 */
  final public SqlNodeList RowConstructorList(SqlParserPos pos) throws ParseException {
    List list = new ArrayList();
    SqlNode rowConstructor;
    rowConstructor = RowConstructor();
                                        list.add(rowConstructor);
    label_7:
    while (true) {
      if (jj_2_14(2)) {
        ;
      } else {
        break label_7;
      }
      jj_consume_token(COMMA);
      rowConstructor = RowConstructor();
                                                    list.add(rowConstructor);
    }
        {if (true) return new SqlNodeList(list, pos.plus(getPos()));}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a row constructor in the context of a VALUES expression.
 */
  final public SqlNode RowConstructor() throws ParseException {
    SqlNodeList valueList;
    SqlNode value;
    SqlParserPos pos;
    if (jj_2_15(3)) {
      jj_consume_token(LPAREN);
                   pos = getPos();
      jj_consume_token(ROW);
      valueList = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_NONCURSOR);
      jj_consume_token(RPAREN);
                   pos = pos.plus(getPos());
    } else if (jj_2_16(3)) {
          pos = getPos();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ROW:
        jj_consume_token(ROW);
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
      valueList = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_NONCURSOR);
          pos = pos.plus(getPos());
    } else if (jj_2_17(1)) {
      value = Expression(ExprContext.ACCEPT_NONCURSOR);
            // NOTE: A bare value here is standard SQL syntax, believe it or
            // not.  Taken together with multi-row table constructors, it leads
            // to very easy mistakes if you forget the parentheses on a
            // single-row constructor.  This is also the reason for the
            // LOOKAHEAD in RowConstructorList().  It would be so much more
            // reasonable to require parentheses.  Sigh.
            pos = value.getParserPosition();
            valueList = new SqlNodeList(Collections.singletonList(value), pos);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
        // REVIEW jvs 8-Feb-2004: Should we discriminate between scalar
        // subqueries inside of ROW and row subqueries?  The standard does,
        // but the distinction seems to be purely syntactic.
        {if (true) return SqlStdOperatorTable.rowConstructor.createCall(
            pos, valueList.toArray());}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the optional WHERE clause for SELECT, DELETE, and UPDATE.
 */
  final public SqlNode WhereOpt() throws ParseException {
    SqlNode condition;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      condition = Expression(ExprContext.ACCEPT_SUBQUERY);
        {if (true) return condition;}
      break;
    default:
      jj_la1[48] = jj_gen;
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the optional GROUP BY clause for SELECT.
 */
  final public SqlNode GroupByOpt() throws ParseException {
    SqlNodeList list;
    SqlNode e;
    SqlParserPos pos;
    if (jj_2_18(4)) {
      jj_consume_token(GROUP);
              pos = getPos();
      jj_consume_token(BY);
      list = ExpressionCommaList(pos, ExprContext.ACCEPT_SUBQUERY);
        {if (true) return list;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP:
        jj_consume_token(GROUP);
        jj_consume_token(BY);
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
        {if (true) return new SqlNodeList(getPos());}
        break;
      default:
        jj_la1[49] = jj_gen;
        {if (true) return null;}
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a list of expressions separated by commas.
 */
  final public SqlNodeList ExpressionCommaList(SqlParserPos pos,
    ExprContext exprContext) throws ParseException {
    List list;
    SqlNode e;
    e = Expression(exprContext);
        if (pos == null) {
            pos = getPos();
        }
        pos = pos.plus(getPos());
        list = startList(e);
    label_8:
    while (true) {
      if (jj_2_19(2)) {
        ;
      } else {
        break label_8;
      }
      jj_consume_token(COMMA);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            list.add(e);
            pos = pos.plus(getPos());
    }
        {if (true) return new SqlNodeList(list, pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the optional HAVING clause for SELECT.
 */
  final public SqlNode HavingOpt() throws ParseException {
    SqlNode e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HAVING:
      jj_consume_token(HAVING);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
        {if (true) return e;}
      break;
    default:
      jj_la1[50] = jj_gen;
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the optional WINDOW clause for SELECT
 */
  final public SqlNodeList WindowOpt() throws ParseException {
    SqlIdentifier id;
    SqlWindow e;
    List list;
    SqlParserPos pos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WINDOW:
      jj_consume_token(WINDOW);
      id = SimpleIdentifier();
      jj_consume_token(AS);
      e = WindowSpecification();
        pos = getPos();
        e.setDeclName(id);
        list = startList(e);
      label_9:
      while (true) {
        if (jj_2_20(2)) {
          ;
        } else {
          break label_9;
        }
        jj_consume_token(COMMA);
        id = SimpleIdentifier();
        jj_consume_token(AS);
        e = WindowSpecification();
            e.setDeclName(id);
            list.add(e);
      }
        {if (true) return new SqlNodeList(list, pos);}
      break;
    default:
      jj_la1[51] = jj_gen;
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a window specification.
 */
  final public SqlWindow WindowSpecification() throws ParseException {
    SqlIdentifier id;
    List list;
    SqlNodeList partitionList;
    SqlNodeList orderList;
    SqlLiteral isRows = SqlLiteral.createBoolean(false, SqlParserPos.ZERO);
    SqlNode lowerBound = null, upperBound = null;
    SqlParserPos startPos;
    SqlParserPos endPos;
    SqlParserPos pos;
    SqlLiteral allowPartial = null;
    jj_consume_token(LPAREN);
               startPos = pos = getPos();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      id = SimpleIdentifier();
      break;
    default:
      jj_la1[52] = jj_gen;
          id = null;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARTITION:
      jj_consume_token(PARTITION);
          pos = getPos();
      jj_consume_token(BY);
      partitionList = ExpressionCommaList(pos, ExprContext.ACCEPT_NONQUERY);
      break;
    default:
      jj_la1[53] = jj_gen;
          partitionList = SqlNodeList.Empty;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      orderList = OrderBy(true);
      break;
    default:
      jj_la1[54] = jj_gen;
          orderList = SqlNodeList.Empty;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANGE:
    case ROWS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ROWS:
        jj_consume_token(ROWS);
                     isRows = SqlLiteral.createBoolean(true, getPos());
        break;
      case RANGE:
        jj_consume_token(RANGE);
                      isRows = SqlLiteral.createBoolean(false, getPos());
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BETWEEN:
        jj_consume_token(BETWEEN);
        lowerBound = WindowRange();
        jj_consume_token(AND);
        upperBound = WindowRange();
        break;
      case CURRENT:
      case DATE:
      case FALSE:
      case INTERVAL:
      case NULL:
      case TIME:
      case TIMESTAMP:
      case TRUE:
      case UNBOUNDED:
      case UNKNOWN:
      case UNSIGNED_INTEGER_LITERAL:
      case APPROX_NUMERIC_LITERAL:
      case DECIMAL_NUMERIC_LITERAL:
      case BINARY_STRING_LITERAL:
      case QUOTED_STRING:
      case PREFIXED_STRING_LITERAL:
      case UNICODE_STRING_LITERAL:
      case LBRACE_D:
      case LBRACE_T:
      case LBRACE_TS:
      case PLUS:
      case MINUS:
        lowerBound = WindowRange();
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALLOW:
    case DISALLOW:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALLOW:
        jj_consume_token(ALLOW);
                  pos = getPos();
        jj_consume_token(PARTIAL);
            allowPartial = SqlLiteral.createBoolean(true, pos.plus(getPos()));
        break;
      case DISALLOW:
        jj_consume_token(DISALLOW);
                     pos = getPos();
        jj_consume_token(PARTIAL);
            allowPartial = SqlLiteral.createBoolean(false, pos.plus(getPos()));
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
        endPos = getPos();
        {if (true) return SqlStdOperatorTable.windowOperator.createCall(
            null, id, partitionList, orderList,
            isRows, lowerBound, upperBound, allowPartial,
            startPos.plus(endPos));}
    throw new Error("Missing return statement in function");
  }

  final public SqlNode WindowRange() throws ParseException {
    SqlNode literal;
    SqlParserPos pos = null;
    SqlParserPos endPos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CURRENT:
      jj_consume_token(CURRENT);
               pos = getPos();
      jj_consume_token(ROW);
        endPos = getPos();
        {if (true) return SqlStdOperatorTable.windowOperator.createCurrentRow(
            pos.plus(endPos));}
      break;
    case UNBOUNDED:
      jj_consume_token(UNBOUNDED);
          pos = getPos();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRECEDING:
        jj_consume_token(PRECEDING);
            endPos = getPos();
            {if (true) return SqlStdOperatorTable.windowOperator.createUnboundedPreceding(
                pos.plus(endPos));}
        break;
      case FOLLOWING:
        jj_consume_token(FOLLOWING);
            endPos = getPos();
            {if (true) return SqlStdOperatorTable.windowOperator.createUnboundedFollowing(
                pos.plus(endPos));}
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case DATE:
    case FALSE:
    case INTERVAL:
    case NULL:
    case TIME:
    case TIMESTAMP:
    case TRUE:
    case UNKNOWN:
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case BINARY_STRING_LITERAL:
    case QUOTED_STRING:
    case PREFIXED_STRING_LITERAL:
    case UNICODE_STRING_LITERAL:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:
    case PLUS:
    case MINUS:
      literal = Literal();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRECEDING:
        jj_consume_token(PRECEDING);
            {if (true) return SqlStdOperatorTable.windowOperator.createPreceding(
                SqlLiteral.unchain(literal), getPos());}
        break;
      case FOLLOWING:
        jj_consume_token(FOLLOWING);
            {if (true) return SqlStdOperatorTable.windowOperator.createFollowing(
                SqlLiteral.unchain(literal), getPos());}
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an ORDER BY clause.
 */
  final public SqlNodeList OrderBy(boolean accept) throws ParseException {
    List list;
    SqlNode e;
    SqlParserPos pos;
    jj_consume_token(ORDER);
        if (!accept) {
            // Someone told us ORDER BY wasn't allowed here.  So why
            // did they bother calling us?  To get the correct
            // parser position for error reporting.
            {if (true) throw SqlUtil.newContextException(
                getPos(),
                EigenbaseResource.instance().IllegalOrderBy.ex());}
        }
    jj_consume_token(BY);
    e = OrderItem();
        pos = getPos();
        list = startList(e);
    label_10:
    while (true) {
      if (jj_2_21(2)) {
        ;
      } else {
        break label_10;
      }
      jj_consume_token(COMMA);
      e = OrderItem();
                                               list.add(e);
    }
        {if (true) return new SqlNodeList(list, pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one list item in an ORDER BY clause.
 */
  final public SqlNode OrderItem() throws ParseException {
    SqlNode e;
    SqlParserPos pos;
    e = Expression(ExprContext.ACCEPT_SUBQUERY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
      jj_consume_token(ASC);
            {if (true) return e;}
      break;
    case DESC:
      jj_consume_token(DESC);
            pos = getPos();
            {if (true) return SqlStdOperatorTable.descendingOperator.createCall(pos, e);}
      break;
    default:
      jj_la1[63] = jj_gen;
            {if (true) return e;}
    }
    throw new Error("Missing return statement in function");
  }

// ----------------------------------------------------------------------------
// Expressions

/**
 * Parses a SQL expression (such as might occur in a WHERE clause) followed by
 * the end-of-file symbol.
 */
  final public SqlNode SqlExpressionEof() throws ParseException {
    SqlNode e;
    e = Expression(ExprContext.ACCEPT_SUBQUERY);
    jj_consume_token(0);
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses either a row expression or a query expression without ORDER BY.
 */
  final public SqlNode QueryOrExpr(ExprContext exprContext) throws ParseException {
    SqlNode e;
    SqlOperator op;
    SqlParserPos pos;
    List list;
    e = LeafQueryOrExpr(exprContext);
        list = startList(e);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCEPT:
      case INTERSECT:
      case UNION:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_11;
      }
            if (!e.isA(SqlKind.QUERY)) {
                // whoops, expression we just parsed wasn't a query,
                // but we're about to see something like UNION, so
                // force an exception retroactively
                checkNonQueryExpression(ExprContext.ACCEPT_QUERY);
            }
      op = BinaryQueryOperator();
            // ensure a query is legal in this context
            pos = getPos();
            checkQueryExpression(exprContext);
      e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY);
            list.add(new SqlParserUtil.ToTreeListItem(op, pos));
            list.add(e);
    }
        e = SqlParserUtil.toTree(list);
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses either a row expression, a leaf query expression, or
 * a parenthesized expression of any kind.
 */
  final public SqlNode LeafQueryOrExpr(ExprContext exprContext) throws ParseException {
    SqlNode e;
    if (jj_2_22(1)) {
      e = Expression(exprContext);
        {if (true) return e;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SELECT:
      case TABLE:
      case VALUES:
        e = LeafQuery(exprContext);
        {if (true) return e;}
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a row expression or a parenthesized expression of any kind.
 */
  final public SqlNode Expression(ExprContext exprContext) throws ParseException {
    List list;
    SqlNode e;
    list = Expression2(exprContext);
        e = SqlParserUtil.toTree(list);
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

// TODO jvs 15-Nov-2003:  ANY/ALL

/**
 * Parses a binary row expression, or a parenthesized expression of any
 * kind.
 *
 * <p>The result is as a flat list of operators and operands. The top-level
 * call to get an expression should call {@link #Expression}, but lower-level
 * calls should call this, to give the parser the opos to associate
 * operator calls.
 *
 * <p>For example 'a = b like c = d' should come out '((a = b) like c) = d'
 * because LIKE and '=' have the same precedence, but tends to come out as '(a
 * = b) like (c = d)' because (a = b) and (c = d) are parsed as separate
 * expressions.
 */
  final public List Expression2(ExprContext exprContext) throws ParseException {
    List list, list2;
    SqlNodeList nodeList;
    SqlNode e;
    SqlOperator op;
    SqlParserPos pos;
    e = Expression3(exprContext);
        list = startList(e);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
    case BETWEEN:
    case IN:
    case IS:
    case LIKE:
    case MEMBER:
    case MULTISET:
    case NOT:
    case OR:
    case SIMILAR:
    case SUBMULTISET:
    case EQ:
    case GT:
    case LT:
    case LE:
    case GE:
    case NE:
    case PLUS:
    case MINUS:
    case STAR:
    case SLASH:
    case CONCAT:
      label_12:
      while (true) {
        if (jj_2_24(2)) {
                    checkNonQueryExpression(exprContext);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NOT:
            jj_consume_token(NOT);
            jj_consume_token(IN);
                        op = SqlStdOperatorTable.notInOperator;
                        pos = getPos();
            break;
          case IN:
            jj_consume_token(IN);
                        op = SqlStdOperatorTable.inOperator;
                        pos = getPos();
            break;
          default:
            jj_la1[66] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          nodeList = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_NONCURSOR);
                    list.add(new SqlParserUtil.ToTreeListItem(op, pos));
                    pos = pos.plus(getPos());
                    // special case for stuff like IN (s1 UNION s2)
                    if (nodeList.size() == 1) {
                        SqlNode item = nodeList.get(0);
                        if (item.isA(SqlKind.QUERY)) {
                            list.add(item);
                        } else {
                            list.add(nodeList);
                        }
                    } else {
                        list.add(nodeList);
                    }
        } else if (jj_2_25(2)) {
                    checkNonQueryExpression(exprContext);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NOT:
            jj_consume_token(NOT);
            jj_consume_token(BETWEEN);
                        op = SqlStdOperatorTable.notBetweenOperator;
                        pos = getPos();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ASYMMETRIC:
            case SYMMETRIC:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case SYMMETRIC:
                jj_consume_token(SYMMETRIC);
                                      op = SqlStdOperatorTable.symmetricNotBetweenOperator;
                break;
              case ASYMMETRIC:
                jj_consume_token(ASYMMETRIC);
                break;
              default:
                jj_la1[67] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[68] = jj_gen;
              ;
            }
            break;
          case BETWEEN:
            jj_consume_token(BETWEEN);
                        op = SqlStdOperatorTable.betweenOperator;
                        pos = getPos();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ASYMMETRIC:
            case SYMMETRIC:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case SYMMETRIC:
                jj_consume_token(SYMMETRIC);
                                      op = SqlStdOperatorTable.symmetricBetweenOperator;
                break;
              case ASYMMETRIC:
                jj_consume_token(ASYMMETRIC);
                break;
              default:
                jj_la1[69] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[70] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[71] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          e = Expression3(ExprContext.ACCEPT_SUBQUERY);
                    list.add(new SqlParserUtil.ToTreeListItem(op, pos));
                    list.add(e);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LIKE:
          case NOT:
          case SIMILAR:
                    checkNonQueryExpression(exprContext);
                    pos = getPos();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case NOT:
              jj_consume_token(NOT);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case LIKE:
                jj_consume_token(LIKE);
                                 op = SqlStdOperatorTable.notLikeOperator;
                break;
              case SIMILAR:
                jj_consume_token(SIMILAR);
                jj_consume_token(TO);
                                         op = SqlStdOperatorTable.notSimilarOperator;
                break;
              default:
                jj_la1[72] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            case LIKE:
              jj_consume_token(LIKE);
                             op = SqlStdOperatorTable.likeOperator;
              break;
            case SIMILAR:
              jj_consume_token(SIMILAR);
              jj_consume_token(TO);
                                     op = SqlStdOperatorTable.similarOperator;
              break;
            default:
              jj_la1[73] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            list2 = Expression2(ExprContext.ACCEPT_SUBQUERY);
                    list.add(new SqlParserUtil.ToTreeListItem(op, pos));
                    list.addAll(list2);
            if (jj_2_23(2)) {
              jj_consume_token(ESCAPE);
              e = Expression3(ExprContext.ACCEPT_SUBQUERY);
                        pos = getPos();
                        list.add(
                            new SqlParserUtil.ToTreeListItem(
                                SqlStdOperatorTable.escapeOperator, pos));
                        list.add(e);
            } else {
              ;
            }
            break;
          default:
            jj_la1[74] = jj_gen;
            if (jj_2_26(3)) {
              op = BinaryRowOperator();
                    checkNonQueryExpression(exprContext);
              e = Expression3(ExprContext.ACCEPT_SUBQUERY);
                    list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
                    list.add(e);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case IS:
                    checkNonQueryExpression(exprContext);
                op = PostfixRowOperator();
                    list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
                break;
              default:
                jj_la1[75] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
        if (jj_2_27(2)) {
          ;
        } else {
          break label_12;
        }
      }
            {if (true) return list;}
      break;
    default:
      jj_la1[76] = jj_gen;
            {if (true) return list;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a unary row expression, or a parenthesized expression of any
 * kind.
 */
  final public SqlNode Expression3(ExprContext exprContext) throws ParseException {
    SqlNode e;
    List list;
    SqlNodeList list1;
    SqlNodeList list2;
    SqlPrefixOperator op;
    boolean rowSeen = false;
    SqlParserPos pos;
    SqlParserPos prefixRowOpPos;
    if (jj_2_28(2)) {
      e = AtomicRowExpression();
        checkNonQueryExpression(exprContext);
        {if (true) return e;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURSOR:
        e = CursorExpression(exprContext);
                                        {if (true) return e;}
        break;
      default:
        jj_la1[80] = jj_gen;
        if (jj_2_29(3)) {
          jj_consume_token(ROW);
          jj_consume_token(LPAREN);
          list = SimpleIdentifierCommaList();
          jj_consume_token(RPAREN);
        pos = getPos();
        if (exprContext != ExprContext.ACCEPT_ALL
            && exprContext != ExprContext.ACCEPT_CURSOR)
        {
            {if (true) throw SqlUtil.newContextException(
                pos,
                EigenbaseResource.instance().IllegalRowExpression.ex());}
        }
        {if (true) return SqlStdOperatorTable.rowConstructor.createCall(
            pos, SqlParserUtil.toNodeArray(list));}
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EXISTS:
          case NOT:
          case PLUS:
          case MINUS:
            op = PrefixRowOperator();
        prefixRowOpPos = getPos();
        checkNonQueryExpression(exprContext);
            e = Expression3(ExprContext.ACCEPT_SUBQUERY);
        SqlParserPos callPos = prefixRowOpPos.plus(e.getParserPosition());
        {if (true) return op.createCall(callPos, e);}
            break;
          case ROW:
          case LPAREN:
        pos = getPos();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ROW:
              jj_consume_token(ROW);
            pos = getPos(); rowSeen = true;
              break;
            default:
              jj_la1[77] = jj_gen;
              ;
            }
            list1 = ParenthesizedQueryOrCommaList(exprContext);
        if (rowSeen) {
            // interpret as row constructor
            {if (true) return SqlStdOperatorTable.rowConstructor.createCall(
                pos, list1.toArray());}

        }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DAY:
            case HOUR:
            case MINUTE:
            case MONTH:
            case OVERLAPS:
            case SECOND:
            case YEAR:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case OVERLAPS:
                jj_consume_token(OVERLAPS);
                list2 = ParenthesizedQueryOrCommaList(exprContext);
                if (list1.size() != 2 || list2.size() != 2) {
                    {if (true) throw SqlUtil.newContextException(
                        list1.getParserPosition().plus(
                            list2.getParserPosition()),
                        EigenbaseResource.instance().IllegalOverlaps.ex());}
                }
                for (SqlNode node : list2) {
                    list1.add(node);
                }
                {if (true) return SqlStdOperatorTable.overlapsOperator.createCall(
                    list1.getParserPosition().plus(list2.getParserPosition()),
                    list1.toArray());}
                break;
              case DAY:
              case HOUR:
              case MINUTE:
              case MONTH:
              case SECOND:
              case YEAR:
                e = IntervalQualifier();
                if ((list1.size() == 1)
                    && list1.get(0) instanceof SqlCall)
                {
                    final SqlCall call = (SqlCall) list1.get(0);
                    if (call.getKind() == SqlKind.MINUS
                        && (call.operands.length == 2))
                    {
                        List list3 = startList(call.operands[0]);
                        list3.add(call.operands[1]);
                        list3.add(e);
                        {if (true) return SqlStdOperatorTable.minusDateOperator.createCall(
                            list1.getParserPosition().plus(getPos()),
                            SqlParserUtil.toNodeArray(list3));}
                     }
                }
                {if (true) throw SqlUtil.newContextException(
                    list1.getParserPosition().plus(getPos()),
                    EigenbaseResource.instance().IllegalMinusDate.ex());}
                break;
              default:
                jj_la1[78] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[79] = jj_gen;
              ;
            }
        if (list1.size() == 1) {
            // interpret as single value or query
            {if (true) return list1.get(0);}
        } else {
            // interpret as row constructor
            {if (true) return SqlStdOperatorTable.rowConstructor.createCall(
                pos, list1.toArray());}
        }
            break;
          default:
            jj_la1[81] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a COLLATE clause
 */
  final public SqlCollation CollateClause() throws ParseException {
    jj_consume_token(COLLATE);
    jj_consume_token(COLLATION_ID);
        {if (true) return new SqlCollation(
            getToken(0).image, SqlCollation.Coercibility.Explicit);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an atomic row expression.
 */
  final public SqlNode AtomicRowExpression() throws ParseException {
    SqlNode e;
    SqlParserPos whenPos;
    SqlParserPos thenPos;
    SqlParserPos pos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE:
    case FALSE:
    case INTERVAL:
    case NULL:
    case TIME:
    case TIMESTAMP:
    case TRUE:
    case UNKNOWN:
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case BINARY_STRING_LITERAL:
    case QUOTED_STRING:
    case PREFIXED_STRING_LITERAL:
    case UNICODE_STRING_LITERAL:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:
    case PLUS:
    case MINUS:
      e = Literal();
                    {if (true) return e;}
      break;
    case HOOK:
      e = DynamicParam();
                         {if (true) return e;}
      break;
    default:
      jj_la1[84] = jj_gen;
      if (jj_2_31(1)) {
        e = BuiltinFunctionCall();
                                {if (true) return e;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE_FN:
          e = JdbcFunctionCall();
                             {if (true) return e;}
          break;
        case MULTISET:
          e = MultisetConstructor();
                                {if (true) return e;}
          break;
        default:
          jj_la1[85] = jj_gen;
          if (jj_2_32(2147483647)) {
            e = NamedFunctionCall();
                              {if (true) return e;}
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CURRENT_CATALOG:
            case CURRENT_DATE:
            case CURRENT_DEFAULT_TRANSFORM_GROUP:
            case CURRENT_PATH:
            case CURRENT_ROLE:
            case CURRENT_SCHEMA:
            case CURRENT_TIME:
            case CURRENT_TIMESTAMP:
            case CURRENT_USER:
            case LOCALTIME:
            case LOCALTIMESTAMP:
            case SESSION_USER:
            case SYSTEM_USER:
            case USER:
              e = ContextVariable();
                            {if (true) return e;}
              break;
            case A:
            case ABSOLUTE:
            case ACTION:
            case ADA:
            case ADD:
            case ADMIN:
            case AFTER:
            case ALWAYS:
            case ASC:
            case ASSERTION:
            case ASSIGNMENT:
            case ATTRIBUTE:
            case ATTRIBUTES:
            case BEFORE:
            case BERNOULLI:
            case BREADTH:
            case C:
            case CASCADE:
            case CATALOG:
            case CATALOG_NAME:
            case CHAIN:
            case CHARACTER_SET_CATALOG:
            case CHARACTER_SET_NAME:
            case CHARACTER_SET_SCHEMA:
            case CHARACTERISTICS:
            case CHARACTERS:
            case CLASS_ORIGIN:
            case COBOL:
            case COLLATION:
            case COLLATION_CATALOG:
            case COLLATION_NAME:
            case COLLATION_SCHEMA:
            case COLUMN_NAME:
            case COMMAND_FUNCTION:
            case COMMAND_FUNCTION_CODE:
            case COMMITTED:
            case CONDITION_NUMBER:
            case CONNECTION:
            case CONNECTION_NAME:
            case CONSTRAINT_CATALOG:
            case CONSTRAINT_NAME:
            case CONSTRAINT_SCHEMA:
            case CONSTRAINTS:
            case CONSTRUCTOR:
            case CONTAINS:
            case CONTINUE:
            case CURSOR_NAME:
            case DATA:
            case DATETIME_INTERVAL_CODE:
            case DATETIME_INTERVAL_PRECISION:
            case DEFAULTS:
            case DEFERRABLE:
            case DEFERRED:
            case DEFINED:
            case DEFINER:
            case DEGREE:
            case DEPTH:
            case DERIVED:
            case DESC:
            case DESCRIPTION:
            case DESCRIPTOR:
            case DIAGNOSTICS:
            case DISPATCH:
            case DOMAIN:
            case DYNAMIC_FUNCTION:
            case DYNAMIC_FUNCTION_CODE:
            case EQUALS:
            case EXCEPTION:
            case EXCLUDE:
            case EXCLUDING:
            case FINAL:
            case FIRST:
            case FOLLOWING:
            case FORTRAN:
            case FOUND:
            case G:
            case GENERAL:
            case GENERATED:
            case GO:
            case GOTO:
            case GRANTED:
            case HIERARCHY:
            case IMMEDIATE:
            case IMPLEMENTATION:
            case INCLUDING:
            case INCREMENT:
            case INITIALLY:
            case INPUT:
            case INSTANCE:
            case INSTANTIABLE:
            case INVOKER:
            case ISOLATION:
            case JAVA:
            case K:
            case KEY:
            case KEY_MEMBER:
            case KEY_TYPE:
            case LABEL:
            case LAST:
            case LENGTH:
            case LEVEL:
            case LIBRARY:
            case LOCATOR:
            case M:
            case MAP:
            case MATCHED:
            case MAXVALUE:
            case MESSAGE_LENGTH:
            case MESSAGE_OCTET_LENGTH:
            case MESSAGE_TEXT:
            case MINVALUE:
            case MORE_KW:
            case MUMPS:
            case NAME:
            case NAMES:
            case NESTING:
            case NEXT:
            case NORMALIZED:
            case NULLABLE:
            case NULLS:
            case NUMBER:
            case OBJECT:
            case OCTETS:
            case OPTION:
            case OPTIONS:
            case ORDERING:
            case ORDINALITY:
            case OTHERS:
            case OUTPUT:
            case OVERRIDING:
            case PAD:
            case PARAMETER_MODE:
            case PARAMETER_NAME:
            case PARAMETER_ORDINAL_POSITION:
            case PARAMETER_SPECIFIC_CATALOG:
            case PARAMETER_SPECIFIC_NAME:
            case PARAMETER_SPECIFIC_SCHEMA:
            case PARTIAL:
            case PASCAL:
            case PASSTHROUGH:
            case PATH:
            case PLACING:
            case PLAN:
            case PLI:
            case PRECEDING:
            case PRESERVE:
            case PRIOR:
            case PRIVILEGES:
            case PUBLIC:
            case READ:
            case RELATIVE:
            case REPEATABLE:
            case RESTART:
            case RESTRICT:
            case RETURNED_CARDINALITY:
            case RETURNED_LENGTH:
            case RETURNED_OCTET_LENGTH:
            case RETURNED_SQLSTATE:
            case ROLE:
            case ROUTINE:
            case ROUTINE_CATALOG:
            case ROUTINE_NAME:
            case ROUTINE_SCHEMA:
            case ROW_COUNT:
            case SCALE:
            case SCHEMA:
            case SCHEMA_NAME:
            case SCOPE_CATALOGS:
            case SCOPE_NAME:
            case SCOPE_SCHEMA:
            case SECTION:
            case SECURITY:
            case SELF:
            case SEQUENCE:
            case SERIALIZABLE:
            case SERVER:
            case SERVER_NAME:
            case SESSION:
            case SETS:
            case SIMPLE:
            case SIZE:
            case SOURCE:
            case SPACE:
            case SPECIFIC_NAME:
            case STATE:
            case STATEMENT:
            case STRUCTURE:
            case STYLE:
            case SUBCLASS_ORIGIN:
            case SUBSTITUTE:
            case TABLE_NAME:
            case TEMPORARY:
            case TIES:
            case TOP_LEVEL_COUNT:
            case TRANSACTION:
            case TRANSACTIONS_ACTIVE:
            case TRANSACTIONS_COMMITTED:
            case TRANSACTIONS_ROLLED_BACK:
            case TRANSFORM:
            case TRANSFORMS:
            case TRIGGER_CATALOG:
            case TRIGGER_NAME:
            case TRIGGER_SCHEMA:
            case TYPE:
            case UNBOUNDED:
            case UNCOMMITTED:
            case UNDER:
            case UNNAMED:
            case USAGE:
            case USER_DEFINED_TYPE_CATALOG:
            case USER_DEFINED_TYPE_CODE:
            case USER_DEFINED_TYPE_NAME:
            case USER_DEFINED_TYPE_SCHEMA:
            case VERSION:
            case VIEW:
            case WORK:
            case WRAPPER:
            case WRITE:
            case XML:
            case ZONE:
            case IDENTIFIER:
            case QUOTED_IDENTIFIER:
            case UNICODE_QUOTED_IDENTIFIER:
              e = CompoundIdentifier();
                               {if (true) return e;}
              break;
            case NEW:
              e = NewSpecification();
                             {if (true) return e;}
              break;
            case CASE:
        SqlNode caseIdentifier=null;
        SqlNode elseClause = null;
        List whenList = new ArrayList();
        List thenList = new ArrayList();
        //sorry there is no wishlist

              jj_consume_token(CASE);
        pos = getPos();
              if (jj_2_30(1)) {
                caseIdentifier = Expression(ExprContext.ACCEPT_SUBQUERY);
              } else {
                ;
              }
              label_13:
              while (true) {
                jj_consume_token(WHEN);
                e = Expression(ExprContext.ACCEPT_SUBQUERY);
           whenPos = getPos(); whenList.add(e);
                jj_consume_token(THEN);
                e = Expression(ExprContext.ACCEPT_SUBQUERY);
           thenPos = getPos(); thenList.add(e);
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case WHEN:
                  ;
                  break;
                default:
                  jj_la1[82] = jj_gen;
                  break label_13;
                }
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case ELSE:
                jj_consume_token(ELSE);
                elseClause = Expression(ExprContext.ACCEPT_SUBQUERY);
                break;
              default:
                jj_la1[83] = jj_gen;
                ;
              }
              jj_consume_token(END);
        pos = pos.plus(getPos());
        {if (true) return SqlStdOperatorTable.caseOperator.createSwitchedCall(
            pos,
            caseIdentifier,
            new SqlNodeList(whenList, whenPos),
            new SqlNodeList(thenList, thenPos),
            elseClause);}
              break;
            default:
              jj_la1[86] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a literal expression, allowing continued string literals.
 * Usually returns an SqlLiteral, but a continued string literal
 * is an SqlCall expression, which concatenates 2 or more string
 * literals; the validator reduces this.
 */
  final public SqlNode Literal() throws ParseException {
    SqlNode e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case PLUS:
    case MINUS:
      e = NumericLiteral();
        {if (true) return e;}
      break;
    case BINARY_STRING_LITERAL:
    case QUOTED_STRING:
    case PREFIXED_STRING_LITERAL:
    case UNICODE_STRING_LITERAL:
      e = StringLiteral();
        {if (true) return e;}
      break;
    case FALSE:
    case NULL:
    case TRUE:
    case UNKNOWN:
      e = SpecialLiteral();
        {if (true) return e;}
      break;
    case DATE:
    case TIME:
    case TIMESTAMP:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:
      e = DateTimeLiteral();
        {if (true) return e;}
      break;
    case INTERVAL:
      e = IntervalLiteral();
        {if (true) return e;}
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** Parses a unsigned numeric literal */
  final public SqlNumericLiteral UnsignedNumericLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNSIGNED_INTEGER_LITERAL:
      jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        {if (true) return SqlLiteral.createExactNumeric(token.image, getPos());}
      break;
    case DECIMAL_NUMERIC_LITERAL:
      jj_consume_token(DECIMAL_NUMERIC_LITERAL);
        {if (true) return SqlLiteral.createExactNumeric(token.image, getPos());}
      break;
    case APPROX_NUMERIC_LITERAL:
      jj_consume_token(APPROX_NUMERIC_LITERAL);
        {if (true) return SqlLiteral.createApproxNumeric(token.image, getPos());}
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** Parses a numeric literal (can be signed) */
  final public SqlLiteral NumericLiteral() throws ParseException {
    SqlNumericLiteral num;
    SqlParserPos pos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
      num = UnsignedNumericLiteral();
        {if (true) return num;}
      break;
    case MINUS:
      jj_consume_token(MINUS);
              pos = getPos();
      num = UnsignedNumericLiteral();
        {if (true) return SqlLiteral.createNegative(num, pos.plus(getPos()));}
      break;
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
      num = UnsignedNumericLiteral();
        {if (true) return num;}
      break;
    default:
      jj_la1[89] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** Parse a special literal keyword */
  final public SqlLiteral SpecialLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
             {if (true) return SqlLiteral.createBoolean(true, getPos());}
      break;
    case FALSE:
      jj_consume_token(FALSE);
              {if (true) return SqlLiteral.createBoolean(false, getPos());}
      break;
    case UNKNOWN:
      jj_consume_token(UNKNOWN);
                {if (true) return SqlLiteral.createUnknown(getPos());}
      break;
    case NULL:
      jj_consume_token(NULL);
             {if (true) return SqlLiteral.createNull(getPos());}
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a string literal. The literal may be continued onto several
 * lines.  For a simple literal, the result is an SqlLiteral.  For a continued
 * literal, the result is an SqlCall expression, which concatenates 2 or more
 * string literals; the validator reduces this.
 *
 * @see SqlLiteral#unchain(SqlNode)
 * @see SqlLiteral#stringValue(SqlNode)
 *
 * @return a literal expression
 */
  final public SqlNode StringLiteral() throws ParseException {
    String p;
    int nfrags = 0;
    List frags = null;
    char unicodeEscapeChar = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BINARY_STRING_LITERAL:
      jj_consume_token(BINARY_STRING_LITERAL);
        try {
            p = SqlParserUtil.trim(token.image, "xX'");
            frags = startList(SqlLiteral.createBinaryString(p, getPos()));
            nfrags++;
        } catch (NumberFormatException ex) {
            {if (true) throw SqlUtil.newContextException(
                getPos(),
                EigenbaseResource.instance().IllegalBinaryString.ex(
                    token.image));}
        }
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QUOTED_STRING:
          ;
          break;
        default:
          jj_la1[91] = jj_gen;
          break label_14;
        }
        jj_consume_token(QUOTED_STRING);
            try {
                p = SqlParserUtil.trim(token.image, "'"); // no embedded quotes
                frags.add(SqlLiteral.createBinaryString(p, getPos()));
                nfrags++;
            } catch (NumberFormatException ex) {
                {if (true) throw SqlUtil.newContextException(
                    getPos(),
                    EigenbaseResource.instance().IllegalBinaryString.ex(
                        token.image));}
            }
      }
        assert (nfrags > 0);
        if (nfrags == 1) {
            {if (true) return (SqlLiteral) frags.get(0);} // just the head fragment
        } else {
            SqlParserPos pos2 = SqlParserPos.sum(frags);
            {if (true) return SqlStdOperatorTable.literalChainOperator.createCall(
                pos2, frags);}
        }
      break;
    case QUOTED_STRING:
    case PREFIXED_STRING_LITERAL:
    case UNICODE_STRING_LITERAL:
        String charSet = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PREFIXED_STRING_LITERAL:
        jj_consume_token(PREFIXED_STRING_LITERAL);
          charSet = SqlParserUtil.getCharacterSet(token.image);
        break;
      case QUOTED_STRING:
        jj_consume_token(QUOTED_STRING);
        break;
      case UNICODE_STRING_LITERAL:
        jj_consume_token(UNICODE_STRING_LITERAL);
            // TODO jvs 2-Feb-2009:  support the explicit specification of
            // a character set for Unicode string literals, per SQL:2003
            unicodeEscapeChar = '\u005c\u005c';
            charSet = "UTF16";
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        p = SqlParserUtil.parseString(token.image);
        SqlCharStringLiteral literal;
        try {
            literal = SqlLiteral.createCharString(p, charSet, getPos());
        } catch (java.nio.charset.UnsupportedCharsetException e) {
            {if (true) throw SqlUtil.newContextException(
                getPos(),
                EigenbaseResource.instance().UnknownCharacterSet.ex(charSet));}
        }
        frags = startList(literal);
        nfrags++;
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QUOTED_STRING:
          ;
          break;
        default:
          jj_la1[93] = jj_gen;
          break label_15;
        }
        jj_consume_token(QUOTED_STRING);
            p = SqlParserUtil.parseString(token.image);
            try {
                literal = SqlLiteral.createCharString(p, charSet, getPos());
            } catch (java.nio.charset.UnsupportedCharsetException e) {
                {if (true) throw SqlUtil.newContextException(
                    getPos(),
                    EigenbaseResource.instance().UnknownCharacterSet.ex(charSet));}
            }
            frags.add(literal);
            nfrags++;
      }

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UESCAPE:
        jj_consume_token(UESCAPE);
        jj_consume_token(QUOTED_STRING);
            if (unicodeEscapeChar == 0) {
                {if (true) throw SqlUtil.newContextException(
                    getPos(),
                    EigenbaseResource.instance().UnicodeEscapeUnexpected.ex());}
            }
            String s = SqlParserUtil.parseString(token.image);
            unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s);
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }

        assert (nfrags > 0);
        if (nfrags == 1) {
            // just the head fragment
            SqlLiteral lit = (SqlLiteral) frags.get(0);
            {if (true) return lit.unescapeUnicode(unicodeEscapeChar);}
        } else {
            SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]);
            for (int i = 0; i < rands.length; ++i) {
                rands[i] = ((SqlLiteral) rands[i]).unescapeUnicode(
                    unicodeEscapeChar);
            }
            SqlParserPos pos2 = SqlParserPos.sum(rands);
            {if (true) return SqlStdOperatorTable.literalChainOperator.createCall(
                pos2, rands);}
        }
      break;
    default:
      jj_la1[95] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a date/time literal.
 */
  final public SqlLiteral DateTimeLiteral() throws ParseException {
    String  p;
    SqlParserPos pos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE_D:
      jj_consume_token(LBRACE_D);
      jj_consume_token(QUOTED_STRING);
        p = token.image;
      jj_consume_token(RBRACE);
        {if (true) return parseDateLiteral(p, getPos());}
      break;
    case LBRACE_T:
      jj_consume_token(LBRACE_T);
      jj_consume_token(QUOTED_STRING);
        p = token.image;
      jj_consume_token(RBRACE);
        {if (true) return parseTimeLiteral(p, getPos());}
      break;
    case LBRACE_TS:
      jj_consume_token(LBRACE_TS);
      jj_consume_token(QUOTED_STRING);
        p = token.image;
      jj_consume_token(RBRACE);
        {if (true) return parseTimestampLiteral(p, getPos());}
      break;
    case DATE:
      jj_consume_token(DATE);
             pos = getPos();
      jj_consume_token(QUOTED_STRING);
        {if (true) return parseDateLiteral(token.image, pos.plus(getPos()));}
      break;
    case TIME:
      jj_consume_token(TIME);
             pos = getPos();
      jj_consume_token(QUOTED_STRING);
        {if (true) return parseTimeLiteral(token.image, pos.plus(getPos()));}
      break;
    case TIMESTAMP:
      jj_consume_token(TIMESTAMP);
                  pos = getPos();
      jj_consume_token(QUOTED_STRING);
        {if (true) return parseTimestampLiteral(token.image, pos.plus(getPos()));}
      break;
    default:
      jj_la1[96] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** Parses a MULTISET constructor */
  final public SqlNode MultisetConstructor() throws ParseException {
    List args;
    SqlNode e;
    SqlParserPos pos;
    if (jj_2_33(2)) {
      jj_consume_token(MULTISET);
                 pos = getPos();
      jj_consume_token(LPAREN);
      //by sub query "MULTISET(SELECT * FROM T)"
          e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY);
      jj_consume_token(RPAREN);
        {if (true) return SqlStdOperatorTable.multisetQueryConstructor.createCall(
            pos.plus(getPos()), e);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTISET:
        jj_consume_token(MULTISET);
                 pos = getPos();
        jj_consume_token(LBRACKET);
        //todo do trigraph aswell ??( ??)
            e = Expression(ExprContext.ACCEPT_NONQUERY);
                                                  args = startList(e);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[97] = jj_gen;
            break label_16;
          }
          jj_consume_token(COMMA);
          e = Expression(ExprContext.ACCEPT_NONQUERY);
                                                              args.add(e);
        }
        jj_consume_token(RBRACKET);
        {if (true) return SqlStdOperatorTable.multisetValueConstructor.createCall(
            pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
        break;
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an interval literal.
 */
  final public SqlLiteral IntervalLiteral() throws ParseException {
    String p;
    SqlIntervalQualifier intervalQualifier;
    int sign = 1;
    SqlParserPos pos;
    jj_consume_token(INTERVAL);
                 pos = getPos();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
                  sign = -1;
        break;
      case PLUS:
        jj_consume_token(PLUS);
                 sign = 1;
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[100] = jj_gen;
      ;
    }
    jj_consume_token(QUOTED_STRING);
                      p = token.image;
    intervalQualifier = IntervalQualifier();
        {if (true) return parseIntervalLiteral(pos.plus(getPos()), sign, p, intervalQualifier);}
    throw new Error("Missing return statement in function");
  }

  final public SqlIntervalQualifier IntervalQualifier() throws ParseException {
    SqlIntervalQualifier.TimeUnit start;
    SqlIntervalQualifier.TimeUnit end = null;
    int startPrec = SqlIntervalQualifier.getDefaultPrecisionId();
    int secondFracPrec = SqlIntervalQualifier.getDefaultPrecisionId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case YEAR:
      jj_consume_token(YEAR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        startPrec = UnsignedIntLiteral();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[101] = jj_gen;
        ;
      }
      if (jj_2_34(2)) {
        jj_consume_token(TO);
        jj_consume_token(MONTH);
                end = SqlIntervalQualifier.TimeUnit.MONTH;
      } else {
        ;
      }
          start = SqlIntervalQualifier.TimeUnit.YEAR;
      break;
    case MONTH:
      jj_consume_token(MONTH);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        startPrec = UnsignedIntLiteral();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[102] = jj_gen;
        ;
      }
          start = SqlIntervalQualifier.TimeUnit.MONTH;
      break;
    case DAY:
      jj_consume_token(DAY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        startPrec = UnsignedIntLiteral();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[103] = jj_gen;
        ;
      }
      if (jj_2_35(2)) {
        jj_consume_token(TO);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HOUR:
          jj_consume_token(HOUR);
                         end = SqlIntervalQualifier.TimeUnit.HOUR;
          break;
        case MINUTE:
          jj_consume_token(MINUTE);
                             end = SqlIntervalQualifier.TimeUnit.MINUTE;
          break;
        case SECOND:
          jj_consume_token(SECOND);
                             end = SqlIntervalQualifier.TimeUnit.SECOND;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            jj_consume_token(LPAREN);
            secondFracPrec = UnsignedIntLiteral();
            jj_consume_token(RPAREN);
            break;
          default:
            jj_la1[104] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[105] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
          start = SqlIntervalQualifier.TimeUnit.DAY;
      break;
    case HOUR:
      jj_consume_token(HOUR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        startPrec = UnsignedIntLiteral();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[106] = jj_gen;
        ;
      }
      if (jj_2_36(2)) {
        jj_consume_token(TO);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUTE:
          jj_consume_token(MINUTE);
                           end = SqlIntervalQualifier.TimeUnit.MINUTE;
          break;
        case SECOND:
          jj_consume_token(SECOND);
                             end = SqlIntervalQualifier.TimeUnit.SECOND;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            jj_consume_token(LPAREN);
            secondFracPrec = UnsignedIntLiteral();
            jj_consume_token(RPAREN);
            break;
          default:
            jj_la1[107] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[108] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
          start = SqlIntervalQualifier.TimeUnit.HOUR;
      break;
    case MINUTE:
      jj_consume_token(MINUTE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        startPrec = UnsignedIntLiteral();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[109] = jj_gen;
        ;
      }
      if (jj_2_37(2)) {
        jj_consume_token(TO);
        jj_consume_token(SECOND);
                           end = SqlIntervalQualifier.TimeUnit.SECOND;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          secondFracPrec = UnsignedIntLiteral();
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[110] = jj_gen;
          ;
        }
      } else {
        ;
      }
          start = SqlIntervalQualifier.TimeUnit.MINUTE;
      break;
    case SECOND:
      jj_consume_token(SECOND);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        startPrec = UnsignedIntLiteral();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          secondFracPrec = UnsignedIntLiteral();
          break;
        default:
          jj_la1[111] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[112] = jj_gen;
        ;
      }
          start = SqlIntervalQualifier.TimeUnit.SECOND;
      break;
    default:
      jj_la1[113] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return new SqlIntervalQualifier(start,
            startPrec,
            end,
            secondFracPrec,
            getPos());}
    throw new Error("Missing return statement in function");
  }

  final public SqlIntervalQualifier.TimeUnit TimeUnit() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case YEAR:
      jj_consume_token(YEAR);
        {if (true) return SqlIntervalQualifier.TimeUnit.YEAR;}
      break;
    case MONTH:
      jj_consume_token(MONTH);
        {if (true) return SqlIntervalQualifier.TimeUnit.MONTH;}
      break;
    case DAY:
      jj_consume_token(DAY);
        {if (true) return SqlIntervalQualifier.TimeUnit.DAY;}
      break;
    case HOUR:
      jj_consume_token(HOUR);
        {if (true) return SqlIntervalQualifier.TimeUnit.HOUR;}
      break;
    case MINUTE:
      jj_consume_token(MINUTE);
        {if (true) return SqlIntervalQualifier.TimeUnit.MINUTE;}
      break;
    case SECOND:
      jj_consume_token(SECOND);
        {if (true) return SqlIntervalQualifier.TimeUnit.SECOND;}
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a dynamic parameter marker.
 */
  final public SqlDynamicParam DynamicParam() throws ParseException {
    SqlParserPos pos;
    jj_consume_token(HOOK);
        pos = getPos();
        {if (true) return new SqlDynamicParam(nDynamicParams++, pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a simple identifier as a string.
 */
  final public String Identifier() throws ParseException {
    String id;
    char unicodeEscapeChar = '\u005c\u005c';
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
            id = getToken(0).image.toUpperCase();
      break;
    case QUOTED_IDENTIFIER:
      jj_consume_token(QUOTED_IDENTIFIER);
            id = SqlParserUtil.strip(getToken(0).image, "\u005c"");
      break;
    case UNICODE_QUOTED_IDENTIFIER:
      jj_consume_token(UNICODE_QUOTED_IDENTIFIER);
            id = getToken(0).image;
            id = id.substring(id.indexOf('"'));
            id = SqlParserUtil.strip(id, "\u005c"");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UESCAPE:
        jj_consume_token(UESCAPE);
        jj_consume_token(QUOTED_STRING);
                String s = SqlParserUtil.parseString(token.image);
                unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s);
        break;
      default:
        jj_la1[115] = jj_gen;
        ;
      }

            SqlLiteral lit = SqlLiteral.createCharString(id, "UTF16", getPos());
            lit = lit.unescapeUnicode(unicodeEscapeChar);
            {if (true) return lit.toValue();}
      break;
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
      id = NonReservedKeyWord();
      break;
    default:
      jj_la1[116] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (id.length() > 128) {
            {if (true) throw SqlUtil.newContextException(
                getPos(),
                EigenbaseResource.instance().IdentifierTooLong.ex(id, 128));}
        }
        {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a simple identifier as an SqlIdentifier.
 */
  final public SqlIdentifier SimpleIdentifier() throws ParseException {
    String p;
    SqlParserPos pos;
    p = Identifier();
                     pos = getPos();
        {if (true) return new SqlIdentifier(p,pos);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a comma-separated list of simple identifiers.
 */
  final public List SimpleIdentifierCommaList() throws ParseException {
    List list = new ArrayList();
    SqlIdentifier id;
    id = SimpleIdentifier();
                             list.add(id);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[117] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      id = SimpleIdentifier();
                                      list.add(id);
    }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a compound identifier.
 */
  final public SqlIdentifier CompoundIdentifier() throws ParseException {
    List list = new ArrayList();
    List posList = new ArrayList();
    String p;
    p = Identifier();
        posList.add(getPos());
        list.add(p);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[118] = jj_gen;
        break label_18;
      }
      jj_consume_token(DOT);
      p = Identifier();
            list.add(p);
            posList.add(getPos());
    }
        SqlParserPos[] componentPositions =
            (SqlParserPos []) posList.toArray(
                new SqlParserPos[posList.size()]);
        SqlParserPos pos = SqlParserPos.sum(componentPositions);
        {if (true) return new SqlIdentifier(
            SqlParserUtil.toStringArray(list), null, pos, componentPositions);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a NEW UDT(...) expression.
 */
  final public SqlNode NewSpecification() throws ParseException {
    SqlParserPos callPos;
    SqlNode routineCall;
    jj_consume_token(NEW);
        callPos = getPos();
    routineCall = NamedRoutineCall(SqlFunctionCategory.UserDefinedConstructor,
            ExprContext.ACCEPT_SUBQUERY);
        {if (true) return SqlStdOperatorTable.newOperator.createCall(
            callPos, routineCall);}
    throw new Error("Missing return statement in function");
  }

//TODO: real parse errors.
  final public int UnsignedIntLiteral() throws ParseException {
    Token t;
    t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        try {
            {if (true) return Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw generateParseException();}
        }
    throw new Error("Missing return statement in function");
  }

  final public int IntLiteral() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNSIGNED_INTEGER_LITERAL:
    case PLUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNSIGNED_INTEGER_LITERAL:
        t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        break;
      case PLUS:
        jj_consume_token(PLUS);
        t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        try {
            {if (true) return Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw generateParseException();}
        }
      break;
    case MINUS:
      jj_consume_token(MINUS);
      t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        try {
            {if (true) return -Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw generateParseException();}
        }
      break;
    default:
      jj_la1[120] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// Type name with optional scale and precision
  final public SqlDataTypeSpec DataType() throws ParseException {
    SqlIdentifier typeName;
    SqlIdentifier collectionTypeName = null;
    int scale = -1;
    int precision = -1;
    String charSetName = null;
    SqlParserPos pos;
    typeName = TypeName();
            pos = getPos();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      precision = UnsignedIntLiteral();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        scale = UnsignedIntLiteral();
        break;
      default:
        jj_la1[121] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[122] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER:
      jj_consume_token(CHARACTER);
      jj_consume_token(SET);
      charSetName = Identifier();
      break;
    default:
      jj_la1[123] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTISET:
      collectionTypeName = CollectionsTypeName();
      break;
    default:
      jj_la1[124] = jj_gen;
      ;
    }
        if (null != collectionTypeName) {
            {if (true) return new SqlDataTypeSpec(
                collectionTypeName,
                typeName,
                precision,
                scale,
                charSetName,
                pos);}
        }
        {if (true) return new SqlDataTypeSpec(
            typeName,
            precision,
            scale,
            charSetName,
            null,
            pos);}
    throw new Error("Missing return statement in function");
  }

// Some SQL type names need special handling due to the fact that they have
// spaces in them but are not quoted.
  final public SqlIdentifier TypeName() throws ParseException {
    SqlIdentifier typeName = null;
    SqlParserPos pos = getPos();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
    case CHARACTER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER:
        jj_consume_token(CHARACTER);
        break;
      case CHAR:
        jj_consume_token(CHAR);
        break;
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            typeName = new SqlIdentifier(
                SqlTypeName.CHAR.name(), pos);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARYING:
        jj_consume_token(VARYING);
                typeName = new SqlIdentifier(
                    SqlTypeName.VARCHAR.name(), pos);
        break;
      default:
        jj_la1[126] = jj_gen;
        ;
      }
      break;
    case VARCHAR:
      jj_consume_token(VARCHAR);
            typeName = new SqlIdentifier(
                SqlTypeName.VARCHAR.name(), pos);
      break;
    case DATE:
      jj_consume_token(DATE);
            typeName = new SqlIdentifier(
                SqlTypeName.DATE.name(),pos);
      break;
    case TIME:
      jj_consume_token(TIME);
            typeName = new SqlIdentifier(
                SqlTypeName.TIME.name(),pos);
      break;
    case TIMESTAMP:
      jj_consume_token(TIMESTAMP);
            typeName = new SqlIdentifier(
                SqlTypeName.TIMESTAMP.name(),pos);
      break;
    case DEC:
    case DECIMAL:
    case NUMERIC:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case DEC:
        jj_consume_token(DEC);
        break;
      case NUMERIC:
        jj_consume_token(NUMERIC);
        break;
      default:
        jj_la1[127] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            typeName = new SqlIdentifier(
                SqlTypeName.DECIMAL.name(),pos);
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
            typeName = new SqlIdentifier(
                SqlTypeName.BOOLEAN.name(),pos);
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
            typeName = new SqlIdentifier(
                SqlTypeName.INTEGER.name(),pos);
      break;
    case INT:
      jj_consume_token(INT);
            typeName = new SqlIdentifier(
                SqlTypeName.INTEGER.name(),pos);
      break;
    case BINARY:
      jj_consume_token(BINARY);
                typeName = new SqlIdentifier(
                    SqlTypeName.BINARY.name(),pos);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARYING:
        jj_consume_token(VARYING);
                typeName = new SqlIdentifier(
                    SqlTypeName.VARBINARY.name(), pos);
        break;
      default:
        jj_la1[128] = jj_gen;
        ;
      }
      break;
    case VARBINARY:
      jj_consume_token(VARBINARY);
            typeName = new SqlIdentifier(
                SqlTypeName.VARBINARY.name(),pos);
      break;
    case TINYINT:
      jj_consume_token(TINYINT);
            typeName = new SqlIdentifier(
                SqlTypeName.TINYINT.name(),pos);
      break;
    case SMALLINT:
      jj_consume_token(SMALLINT);
            typeName = new SqlIdentifier(
                SqlTypeName.SMALLINT.name(),pos);
      break;
    case BIGINT:
      jj_consume_token(BIGINT);
            typeName = new SqlIdentifier(
                SqlTypeName.BIGINT.name(),pos);
      break;
    case REAL:
      jj_consume_token(REAL);
            typeName = new SqlIdentifier(
                SqlTypeName.REAL.name(),pos);
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRECISION:
        jj_consume_token(PRECISION);
        break;
      default:
        jj_la1[129] = jj_gen;
        ;
      }
            typeName = new SqlIdentifier(
                SqlTypeName.DOUBLE.name(),pos);
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
            typeName = new SqlIdentifier(
                SqlTypeName.FLOAT.name(),pos);
      break;
    case MULTISET:
      typeName = CollectionsTypeName();
      break;
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      typeName = CompoundIdentifier();
      break;
    default:
      jj_la1[130] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return typeName;}
    throw new Error("Missing return statement in function");
  }

  final public SqlIdentifier CollectionsTypeName() throws ParseException {
    SqlIdentifier typeName = null;
    SqlParserPos pos = getPos();
    jj_consume_token(MULTISET);
        typeName = new SqlIdentifier(
            SqlTypeName.MULTISET.name(),pos);
        {if (true) return typeName;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a CURSOR(query) expression.  The parser allows these
 * anywhere, but the validator restricts them to appear only as
 * arguments to table functions.
 */
  final public SqlNode CursorExpression(ExprContext exprContext) throws ParseException {
    SqlNode e;
    SqlParserPos pos;
    jj_consume_token(CURSOR);
        pos = getPos();
        if (exprContext != ExprContext.ACCEPT_ALL
            && exprContext != ExprContext.ACCEPT_CURSOR)
        {
            {if (true) throw SqlUtil.newContextException(
                pos,
                EigenbaseResource.instance().IllegalCursorExpression.ex());}
        }
    e = Expression(ExprContext.ACCEPT_QUERY);
        {if (true) return SqlStdOperatorTable.cursorConstructor.createCall(
            pos, e);}
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a call to a builtin function with special syntax.
 */
  final public SqlNode BuiltinFunctionCall() throws ParseException {
    String name;
    List args = null;
    SqlNode e = null;
    SqlParserPos pos;
    SqlParserPos starPos;
    SqlParserPos namePos;
    SqlDataTypeSpec dt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CAST:
      jj_consume_token(CAST);
            pos = getPos();
      jj_consume_token(LPAREN);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
                                                               args = startList(e);
      jj_consume_token(AS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BIGINT:
      case BINARY:
      case BOOLEAN:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CHAIN:
      case CHAR:
      case CHARACTER:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTAINS:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DEC:
      case DECIMAL:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOUBLE:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case EQUALS:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FLOAT:
      case FOLLOWING:
      case FORTRAN:
      case FOUND:
      case G:
      case GENERAL:
      case GENERATED:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INT:
      case INTEGER:
      case INVOKER:
      case ISOLATION:
      case JAVA:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MINVALUE:
      case MORE_KW:
      case MULTISET:
      case MUMPS:
      case NAME:
      case NAMES:
      case NESTING:
      case NEXT:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case NUMERIC:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSTHROUGH:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case READ:
      case REAL:
      case RELATIVE:
      case REPEATABLE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SMALLINT:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIME:
      case TIMESTAMP:
      case TINYINT:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case VARCHAR:
      case VARBINARY:
      case VERSION:
      case VIEW:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:
        dt = DataType();
                              args.add(dt);
        break;
      case INTERVAL:
        jj_consume_token(INTERVAL);
        e = IntervalQualifier();
                                                    args.add(e);
        break;
      default:
        jj_la1[131] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.castFunc.createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
      break;
    case EXTRACT:
      jj_consume_token(EXTRACT);
            pos = getPos();
            SqlIntervalQualifier.TimeUnit unit;
      jj_consume_token(LPAREN);
      unit = TimeUnit();
          args = startList(new SqlIntervalQualifier(unit, null,getPos()));
      jj_consume_token(FROM);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
                                                      args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.extractFunc.createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
      break;
    case POSITION:
      jj_consume_token(POSITION);
            pos = getPos();
      jj_consume_token(LPAREN);
      // FIXME jvs 31-Aug-2006:  FRG-192:  This should be
              // Expression(ExprContext.ACCEPT_SUBQUERY), but that doesn't work
              // because it matches the other kind of IN.
              e = AtomicRowExpression();
                                    args = startList(e);
      jj_consume_token(IN);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
                                                      args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.positionFunc.createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
      break;
    case CONVERT:
      jj_consume_token(CONVERT);
            pos = getPos();
      jj_consume_token(LPAREN);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            args = startList(e);
      jj_consume_token(USING);
      name = Identifier();
            namePos = getPos();
            args.add(new SqlIdentifier(name, namePos));
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.convertFunc.createCall(
                pos, SqlParserUtil.toNodeArray(args));}
      break;
    case TRANSLATE:
      jj_consume_token(TRANSLATE);
            pos = getPos();
      jj_consume_token(LPAREN);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            args = startList(e);
      jj_consume_token(USING);
      name = Identifier();
            namePos = getPos();
            args.add(new SqlIdentifier(name, namePos));
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.translateFunc.createCall(
                pos, SqlParserUtil.toNodeArray(args));}
      break;
    case OVERLAY:
      jj_consume_token(OVERLAY);
            pos = getPos();
      jj_consume_token(LPAREN);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            args = startList(e);
      jj_consume_token(PLACING);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            args.add(e);
      jj_consume_token(FROM);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            args.add(e);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOR:
        jj_consume_token(FOR);
        e = Expression(ExprContext.ACCEPT_SUBQUERY);
                args.add(e);
        break;
      default:
        jj_la1[132] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.overlayFunc.createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
      break;
    case FLOOR:
      jj_consume_token(FLOOR);
      e = FloorCeilOptions(getPos(), true);
          {if (true) return e;}
      break;
    case CEIL:
    case CEILING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CEIL:
        jj_consume_token(CEIL);
        break;
      case CEILING:
        jj_consume_token(CEILING);
        break;
      default:
        jj_la1[133] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      e = FloorCeilOptions(getPos(), false);
          {if (true) return e;}
      break;
    case SUBSTRING:
      jj_consume_token(SUBSTRING);
            pos = getPos();
      jj_consume_token(LPAREN);
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
          args = startList(e);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        jj_consume_token(FROM);
        break;
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[134] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
          args.add(e);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOR:
      case COMMA:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
          jj_consume_token(FOR);
          break;
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[135] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        e = Expression(ExprContext.ACCEPT_SUBQUERY);
              args.add(e);
        break;
      default:
        jj_la1[136] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.substringFunc.createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
      break;
    case TRIM:
      jj_consume_token(TRIM);
            SqlLiteral flag = null;
            SqlNode trimChars = null;
            pos = getPos();
      jj_consume_token(LPAREN);
      if (jj_2_39(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOTH:
        case LEADING:
        case TRAILING:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOTH:
            jj_consume_token(BOTH);
                    pos = getPos();
                    flag = SqlLiteral.createSymbol(
                        SqlTrimFunction.Flag.BOTH, pos);
            break;
          case TRAILING:
            jj_consume_token(TRAILING);
                    pos = getPos();
                    flag = SqlLiteral.createSymbol(
                        SqlTrimFunction.Flag.TRAILING, pos);
            break;
          case LEADING:
            jj_consume_token(LEADING);
                    pos = getPos();
                    flag = SqlLiteral.createSymbol(
                        SqlTrimFunction.Flag.LEADING, pos);
            break;
          default:
            jj_la1[137] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[138] = jj_gen;
          ;
        }
        if (jj_2_38(1)) {
          trimChars = Expression(ExprContext.ACCEPT_SUBQUERY);
        } else {
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          jj_consume_token(FROM);
                    if (null == flag && null == trimChars) {
                        {if (true) throw SqlUtil.newContextException(
                            getPos(),
                            EigenbaseResource.instance().IllegalFromEmpty.ex());}
                    }
          break;
        case RPAREN:
          jj_consume_token(RPAREN);
                    // This is to handle the case of TRIM(x)
                    // (FRG-191).
                    args = startList(flag);
                    args.add(null); // no trim chars
                    args.add(trimChars); // reinterpret trimChars as source
                    {if (true) return SqlStdOperatorTable.trimFunc.createCall(
                        pos, SqlParserUtil.toNodeArray(args));}
          break;
        default:
          jj_la1[139] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      e = Expression(ExprContext.ACCEPT_SUBQUERY);
            args = startList(flag);
            args.add(trimChars);
            args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return SqlStdOperatorTable.trimFunc.createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
      break;
    default:
      jj_la1[140] = jj_gen;
      if (jj_2_40(1)) {
        SqlNode node;
        node = ExtendedBuiltinFunctionCall();
        {if (true) return node;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a call to a named function (could be a builtin with regular
 * syntax, or else a UDF).
 *
 *<p>
 *
 * NOTE: every UDF has two names: an <em>invocation name</em> and a
 * <em>specific name</em>.  Normally, function calls are resolved via overload
 * resolution and invocation names.  The SPECIFIC prefix allows overload
 * resolution to be bypassed.  Note that usage of the SPECIFIC prefix in
 * queries is non-standard; it is used internally by Farrago, e.g. in stored
 * view definitions to permanently bind references to a particular function
 * after the overload resolution performed by view creation.
 *
 *<p>
 *
 * TODO jvs 25-Mar-2005:  Once we have SQL-Flagger support, flag SPECIFIC
 * as non-standard.
 */
  final public SqlNode NamedFunctionCall() throws ParseException {
    SqlIdentifier qualifiedName;
    SqlIdentifier id = null;
    List args;
    SqlParserPos pos;
    SqlParserPos starPos;
    SqlParserPos overPos = null;
    boolean over = false;
    SqlCall function = null;
    SqlFunctionCategory funcType =
        SqlFunctionCategory.UserDefinedFunction;
    SqlNode e = null;
    SqlLiteral quantifier = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SPECIFIC:
      jj_consume_token(SPECIFIC);
            funcType = SqlFunctionCategory.UserDefinedSpecificFunction;
      break;
    default:
      jj_la1[141] = jj_gen;
      ;
    }
    qualifiedName = FunctionName();
            pos = getPos();
    if (jj_2_41(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(STAR);
                                           starPos = getPos();
      jj_consume_token(RPAREN);
                args = startList(new SqlIdentifier("*", starPos));
                pos = pos.plus(getPos());
    } else if (jj_2_42(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
                args = SqlParserUtil.emptyList;
                pos = pos.plus(getPos());
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        args = FunctionParameterList(ExprContext.ACCEPT_SUBQUERY);
                pos = pos.plus(getPos());
                quantifier = (SqlLiteral) args.get(0);
                args.remove(0);
        break;
      default:
        jj_la1[142] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OVER:
      jj_consume_token(OVER);
                overPos = getPos();
                over = true;
                pos = pos.plus(overPos);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTAINS:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case EQUALS:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORTRAN:
      case FOUND:
      case G:
      case GENERAL:
      case GENERATED:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISOLATION:
      case JAVA:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MINVALUE:
      case MORE_KW:
      case MUMPS:
      case NAME:
      case NAMES:
      case NESTING:
      case NEXT:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSTHROUGH:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case VERSION:
      case VIEW:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:
        id = SimpleIdentifier();
        break;
      case LPAREN:
        e = WindowSpecification();
        break;
      default:
        jj_la1[143] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[144] = jj_gen;
      ;
    }
            function = createCall(
                qualifiedName, pos, funcType, quantifier,
                SqlParserUtil.toNodeArray(args));

            if (over) {
                if (id != null) {
                    {if (true) return SqlStdOperatorTable.overOperator.createCall(
                        overPos, new SqlNode[] {function, id});}
                } else {
                    {if (true) return SqlStdOperatorTable.overOperator.createCall(
                        overPos, new SqlNode[] { function, e });}
                }
            } else {
                {if (true) return function;}
            }
    throw new Error("Missing return statement in function");
  }

/*
* Parse Floor/Ceil function parameters
*/
  final public SqlNode StandardFloorCeilOptions(SqlParserPos pos, boolean floorFlag) throws ParseException {
    SqlIdentifier name;
    SqlParserPos overPos = null;
    SqlIdentifier id = null;
    SqlNode e = null;
    SqlCall function = null;
    SqlNodeList args;
    boolean over = false;
    args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUBQUERY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OVER:
      jj_consume_token(OVER);
            overPos = getPos();
            over = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTAINS:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case EQUALS:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORTRAN:
      case FOUND:
      case G:
      case GENERAL:
      case GENERATED:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISOLATION:
      case JAVA:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MINVALUE:
      case MORE_KW:
      case MUMPS:
      case NAME:
      case NAMES:
      case NESTING:
      case NEXT:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSTHROUGH:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case VERSION:
      case VIEW:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:
        id = SimpleIdentifier();
        break;
      case LPAREN:
        e = WindowSpecification();
        break;
      default:
        jj_la1[145] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[146] = jj_gen;
      ;
    }
        SqlOperator op = floorFlag ?
            SqlStdOperatorTable.floorFunc :
            SqlStdOperatorTable.ceilFunc;
        function =  op.createCall(
            pos, args.toArray());
        if (over) {
            if (id != null) {
                {if (true) return SqlStdOperatorTable.overOperator.createCall(
                    overPos, new SqlNode[] {function, id});}
            } else {
                {if (true) return SqlStdOperatorTable.overOperator.createCall(
                    overPos, new SqlNode[] { function, e });}
            }
        } else {
            {if (true) return function;}
        }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the name of a JDBC function that is a token but is not reserved.
 */
  final public String NonReservedJdbcFunctionName() throws ParseException {
    jj_consume_token(SUBSTRING);
        {if (true) return getToken(0).image.toUpperCase();}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the name of a function (either a compound identifier or
 * a reserved word which can be used as a function name).
 */
  final public SqlIdentifier FunctionName() throws ParseException {
    SqlIdentifier qualifiedName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      qualifiedName = CompoundIdentifier();
      break;
    case ABS:
    case AVG:
    case CARDINALITY:
    case CHAR_LENGTH:
    case CHARACTER_LENGTH:
    case COALESCE:
    case COLLECT:
    case COUNT:
    case CUME_DIST:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case DENSE_RANK:
    case ELEMENT:
    case EXP:
    case FIRST_VALUE:
    case FUSION:
    case LAST_VALUE:
    case LN:
    case LOCALTIME:
    case LOCALTIMESTAMP:
    case LOWER:
    case MAX:
    case MIN:
    case MOD:
    case NULLIF:
    case OCTET_LENGTH:
    case PERCENT_RANK:
    case POWER:
    case RANK:
    case ROW_NUMBER:
    case SQRT:
    case STDDEV_POP:
    case STDDEV_SAMP:
    case SUM:
    case UPPER:
    case VAR_POP:
    case VAR_SAMP:
      qualifiedName = ReservedFunctionName();
      break;
    default:
      jj_la1[147] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return qualifiedName;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a reserved word which is used as the name of a function.
 */
  final public SqlIdentifier ReservedFunctionName() throws ParseException {
    SqlIdentifier name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABS:
      jj_consume_token(ABS);
      break;
    case AVG:
      jj_consume_token(AVG);
      break;
    case CARDINALITY:
      jj_consume_token(CARDINALITY);
      break;
    case CHAR_LENGTH:
      jj_consume_token(CHAR_LENGTH);
      break;
    case CHARACTER_LENGTH:
      jj_consume_token(CHARACTER_LENGTH);
      break;
    case COALESCE:
      jj_consume_token(COALESCE);
      break;
    case COLLECT:
      jj_consume_token(COLLECT);
      break;
    case CUME_DIST:
      jj_consume_token(CUME_DIST);
      break;
    case COUNT:
      jj_consume_token(COUNT);
      break;
    case CURRENT_DATE:
      jj_consume_token(CURRENT_DATE);
      break;
    case CURRENT_TIME:
      jj_consume_token(CURRENT_TIME);
      break;
    case CURRENT_TIMESTAMP:
      jj_consume_token(CURRENT_TIMESTAMP);
      break;
    case DENSE_RANK:
      jj_consume_token(DENSE_RANK);
      break;
    case ELEMENT:
      jj_consume_token(ELEMENT);
      break;
    case EXP:
      jj_consume_token(EXP);
      break;
    case FIRST_VALUE:
      jj_consume_token(FIRST_VALUE);
      break;
    case FUSION:
      jj_consume_token(FUSION);
      break;
    case LAST_VALUE:
      jj_consume_token(LAST_VALUE);
      break;
    case LN:
      jj_consume_token(LN);
      break;
    case LOCALTIME:
      jj_consume_token(LOCALTIME);
      break;
    case LOCALTIMESTAMP:
      jj_consume_token(LOCALTIMESTAMP);
      break;
    case LOWER:
      jj_consume_token(LOWER);
      break;
    case MAX:
      jj_consume_token(MAX);
      break;
    case MIN:
      jj_consume_token(MIN);
      break;
    case MOD:
      jj_consume_token(MOD);
      break;
    case NULLIF:
      jj_consume_token(NULLIF);
      break;
    case OCTET_LENGTH:
      jj_consume_token(OCTET_LENGTH);
      break;
    case PERCENT_RANK:
      jj_consume_token(PERCENT_RANK);
      break;
    case POWER:
      jj_consume_token(POWER);
      break;
    case RANK:
      jj_consume_token(RANK);
      break;
    case ROW_NUMBER:
      jj_consume_token(ROW_NUMBER);
      break;
    case SQRT:
      jj_consume_token(SQRT);
      break;
    case STDDEV_POP:
      jj_consume_token(STDDEV_POP);
      break;
    case STDDEV_SAMP:
      jj_consume_token(STDDEV_SAMP);
      break;
    case SUM:
      jj_consume_token(SUM);
      break;
    case UPPER:
      jj_consume_token(UPPER);
      break;
    case VAR_POP:
      jj_consume_token(VAR_POP);
      break;
    case VAR_SAMP:
      jj_consume_token(VAR_SAMP);
      break;
    default:
      jj_la1[148] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        name = new SqlIdentifier(
            getToken(0).image.toUpperCase(), getPos());
        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public SqlIdentifier ContextVariable() throws ParseException {
    SqlIdentifier name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CURRENT_CATALOG:
      jj_consume_token(CURRENT_CATALOG);
      break;
    case CURRENT_DATE:
      jj_consume_token(CURRENT_DATE);
      break;
    case CURRENT_DEFAULT_TRANSFORM_GROUP:
      jj_consume_token(CURRENT_DEFAULT_TRANSFORM_GROUP);
      break;
    case CURRENT_PATH:
      jj_consume_token(CURRENT_PATH);
      break;
    case CURRENT_ROLE:
      jj_consume_token(CURRENT_ROLE);
      break;
    case CURRENT_SCHEMA:
      jj_consume_token(CURRENT_SCHEMA);
      break;
    case CURRENT_TIME:
      jj_consume_token(CURRENT_TIME);
      break;
    case CURRENT_TIMESTAMP:
      jj_consume_token(CURRENT_TIMESTAMP);
      break;
    case CURRENT_USER:
      jj_consume_token(CURRENT_USER);
      break;
    case LOCALTIME:
      jj_consume_token(LOCALTIME);
      break;
    case LOCALTIMESTAMP:
      jj_consume_token(LOCALTIMESTAMP);
      break;
    case SESSION_USER:
      jj_consume_token(SESSION_USER);
      break;
    case SYSTEM_USER:
      jj_consume_token(SYSTEM_USER);
      break;
    case USER:
      jj_consume_token(USER);
      break;
    default:
      jj_la1[149] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        name = new SqlIdentifier(
            getToken(0).image.toUpperCase(), getPos());
        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a function call expression with JDBC syntax.
 */
  final public SqlNode JdbcFunctionCall() throws ParseException {
    String name;
    SqlIdentifier id;
    SqlNodeList args;
    SqlParserPos pos;
    SqlParserPos starPos;
    jj_consume_token(LBRACE_FN);
            pos = getPos();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSERT:
      jj_consume_token(INSERT);
                       name = getToken(0).image.toUpperCase();
      break;
    case ABS:
    case AVG:
    case CARDINALITY:
    case CHAR_LENGTH:
    case CHARACTER_LENGTH:
    case COALESCE:
    case COLLECT:
    case COUNT:
    case CUME_DIST:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case DENSE_RANK:
    case ELEMENT:
    case EXP:
    case FIRST_VALUE:
    case FUSION:
    case LAST_VALUE:
    case LN:
    case LOCALTIME:
    case LOCALTIMESTAMP:
    case LOWER:
    case MAX:
    case MIN:
    case MOD:
    case NULLIF:
    case OCTET_LENGTH:
    case PERCENT_RANK:
    case POWER:
    case RANK:
    case ROW_NUMBER:
    case SQRT:
    case STDDEV_POP:
    case STDDEV_SAMP:
    case SUM:
    case UPPER:
    case VAR_POP:
    case VAR_SAMP:
      // For cases like {fn power(1,2)} and {fn lower('a')}
                  id = ReservedFunctionName();
                                          name = id.getSimple();
      break;
    case SUBSTRING:
      // For cases like {fn substring('foo', 1,2)}
                  name = NonReservedJdbcFunctionName();
      break;
    case A:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTAINS:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case EQUALS:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORTRAN:
    case FOUND:
    case G:
    case GENERAL:
    case GENERATED:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IMMEDIATE:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISOLATION:
    case JAVA:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MINVALUE:
    case MORE_KW:
    case MUMPS:
    case NAME:
    case NAMES:
    case NESTING:
    case NEXT:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSTHROUGH:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case VERSION:
    case VIEW:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:
      name = Identifier();
      break;
    default:
      jj_la1[150] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_43(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(STAR);
                                          starPos = getPos();
      jj_consume_token(RPAREN);
                args = new SqlNodeList(starPos);
                args.add(new SqlIdentifier("*", starPos));
    } else if (jj_2_44(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
              args = new SqlNodeList(pos);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUBQUERY);
        break;
      default:
        jj_la1[151] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
            {if (true) return new SqlJdbcFunctionCall(name).createCall(
                pos.plus(getPos()), SqlParserUtil.toNodeArray(args));}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a binary query operator like UNION.
 */
  final public SqlBinaryOperator BinaryQueryOperator() throws ParseException {
    SqlBinaryOperator op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNION:
      jj_consume_token(UNION);
                  op = SqlStdOperatorTable.unionOperator;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
                    op = SqlStdOperatorTable.unionAllOperator;
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
                           op = SqlStdOperatorTable.unionOperator;
          break;
        default:
          jj_la1[152] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[153] = jj_gen;
        ;
      }
      break;
    case INTERSECT:
      jj_consume_token(INTERSECT);
                      op = SqlStdOperatorTable.intersectOperator;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
                    op = SqlStdOperatorTable.intersectAllOperator;
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
                           op = SqlStdOperatorTable.intersectOperator;
          break;
        default:
          jj_la1[154] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[155] = jj_gen;
        ;
      }
      break;
    case EXCEPT:
      jj_consume_token(EXCEPT);
                   op = SqlStdOperatorTable.exceptOperator;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
                    op = SqlStdOperatorTable.exceptAllOperator;
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
                           op = SqlStdOperatorTable.exceptOperator;
          break;
        default:
          jj_la1[156] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[157] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[158] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a binary multiset operator.
 */
  final public SqlBinaryOperator BinaryMultisetOperator() throws ParseException {
    SqlBinaryOperator op;
    jj_consume_token(MULTISET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNION:
      jj_consume_token(UNION);
                      op = SqlStdOperatorTable.multisetUnionOperator;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
                        op = SqlStdOperatorTable.multisetUnionAllOperator;
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
                               op = SqlStdOperatorTable.multisetUnionOperator;
          break;
        default:
          jj_la1[159] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[160] = jj_gen;
        ;
      }
      break;
    case INTERSECT:
      jj_consume_token(INTERSECT);
                          op = SqlStdOperatorTable.multisetIntersectOperator;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
                        op = SqlStdOperatorTable.multisetIntersectAllOperator;
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
                               op = SqlStdOperatorTable.multisetIntersectOperator;
          break;
        default:
          jj_la1[161] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[162] = jj_gen;
        ;
      }
      break;
    case EXCEPT:
      jj_consume_token(EXCEPT);
                       op = SqlStdOperatorTable.multisetExceptOperator;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
                        op = SqlStdOperatorTable.multisetExceptAllOperator;
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
                               op = SqlStdOperatorTable.multisetExceptOperator;
          break;
        default:
          jj_la1[163] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[164] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[165] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a binary row operator like AND.
 */
  final public SqlBinaryOperator BinaryRowOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      jj_consume_token(EQ);
      {if (true) return SqlStdOperatorTable.equalsOperator;}
      break;
    case GT:
      jj_consume_token(GT);
      {if (true) return SqlStdOperatorTable.greaterThanOperator;}
      break;
    case LT:
      jj_consume_token(LT);
      {if (true) return SqlStdOperatorTable.lessThanOperator;}
      break;
    case LE:
      jj_consume_token(LE);
      {if (true) return SqlStdOperatorTable.lessThanOrEqualOperator;}
      break;
    case GE:
      jj_consume_token(GE);
      {if (true) return SqlStdOperatorTable.greaterThanOrEqualOperator;}
      break;
    case NE:
      jj_consume_token(NE);
      {if (true) return SqlStdOperatorTable.notEqualsOperator;}
      break;
    case PLUS:
      jj_consume_token(PLUS);
      {if (true) return SqlStdOperatorTable.plusOperator;}
      break;
    case MINUS:
      jj_consume_token(MINUS);
      {if (true) return SqlStdOperatorTable.minusOperator;}
      break;
    case STAR:
      jj_consume_token(STAR);
      {if (true) return SqlStdOperatorTable.multiplyOperator;}
      break;
    case SLASH:
      jj_consume_token(SLASH);
      {if (true) return SqlStdOperatorTable.divideOperator;}
      break;
    case CONCAT:
      jj_consume_token(CONCAT);
      {if (true) return SqlStdOperatorTable.concatOperator;}
      break;
    case AND:
      jj_consume_token(AND);
      {if (true) return SqlStdOperatorTable.andOperator;}
      break;
    case OR:
      jj_consume_token(OR);
      {if (true) return SqlStdOperatorTable.orOperator;}
      break;
    default:
      jj_la1[166] = jj_gen;
      if (jj_2_45(2)) {
        jj_consume_token(IS);
        jj_consume_token(DISTINCT);
        jj_consume_token(FROM);
      {if (true) return SqlStdOperatorTable.isDistinctFromOperator;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IS:
          jj_consume_token(IS);
          jj_consume_token(NOT);
          jj_consume_token(DISTINCT);
          jj_consume_token(FROM);
      {if (true) return SqlStdOperatorTable.isNotDistinctFromOperator;}
          break;
        case MEMBER:
          jj_consume_token(MEMBER);
          jj_consume_token(OF);
      {if (true) return SqlStdOperatorTable.memberOfOperator;}
          break;
        case SUBMULTISET:
          jj_consume_token(SUBMULTISET);
          jj_consume_token(OF);
      {if (true) return SqlStdOperatorTable.submultisetOfOperator;}
          break;
        case MULTISET:
      SqlBinaryOperator op;
          op = BinaryMultisetOperator();
      {if (true) return op;}
          break;
        default:
          jj_la1[167] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a prefix row operator like NOT.
 */
  final public SqlPrefixOperator PrefixRowOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
             {if (true) return SqlStdOperatorTable.prefixPlusOperator;}
      break;
    case MINUS:
      jj_consume_token(MINUS);
                {if (true) return SqlStdOperatorTable.prefixMinusOperator;}
      break;
    case NOT:
      jj_consume_token(NOT);
              {if (true) return SqlStdOperatorTable.notOperator;}
      break;
    case EXISTS:
      jj_consume_token(EXISTS);
                 {if (true) return SqlStdOperatorTable.existsOperator;}
      break;
    default:
      jj_la1[168] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a postfix row operator like IS NOT NULL.
 */
  final public SqlPostfixOperator PostfixRowOperator() throws ParseException {
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
      jj_consume_token(A);
      jj_consume_token(SET);
                    {if (true) return SqlStdOperatorTable.isASetOperator;}
      break;
    case NOT:
      jj_consume_token(NOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULL:
        jj_consume_token(NULL);
                     {if (true) return SqlStdOperatorTable.isNotNullOperator;}
        break;
      case TRUE:
        jj_consume_token(TRUE);
                       {if (true) return SqlStdOperatorTable.isNotTrueOperator;}
        break;
      case FALSE:
        jj_consume_token(FALSE);
                        {if (true) return SqlStdOperatorTable.isNotFalseOperator;}
        break;
      case UNKNOWN:
        jj_consume_token(UNKNOWN);
                          {if (true) return SqlStdOperatorTable.isNotUnknownOperator;}
        break;
      default:
        jj_la1[169] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case FALSE:
    case NULL:
    case TRUE:
    case UNKNOWN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULL:
        jj_consume_token(NULL);
                     {if (true) return SqlStdOperatorTable.isNullOperator;}
        break;
      case TRUE:
        jj_consume_token(TRUE);
                       {if (true) return SqlStdOperatorTable.isTrueOperator;}
        break;
      case FALSE:
        jj_consume_token(FALSE);
                        {if (true) return SqlStdOperatorTable.isFalseOperator;}
        break;
      case UNKNOWN:
        jj_consume_token(UNKNOWN);
                          {if (true) return SqlStdOperatorTable.isUnknownOperator;}
        break;
      default:
        jj_la1[170] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[171] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * Abstract production:
 *
 *   String NonReservedKeyWord()
 *
 * Parses non-reserved keywords (e.g. keywords that may be used as
 * identifiers).  Should use CommonNonReservedKeyWord as a base, but
 * may add other key words.
 */

/**
 * Parses a non-reserved keyword for use as an identifier.  Specializations
 * of this parser can use this as a base for implementing the
 * NonReservedKeyWord() production.
 *
 *<p>
 *
 * When adding keywords to this list, be sure that they are not reserved
 * by the SQL:2003 standard (see productions for "non-reserved word"
 * and "reserved word" in reference below).
 *
 * @sql.2003 Part 2 Section 5.2
 */
  final public String CommonNonReservedKeyWord() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
      jj_consume_token(A);
      break;
    case ABSOLUTE:
      jj_consume_token(ABSOLUTE);
      break;
    case ACTION:
      jj_consume_token(ACTION);
      break;
    case ADA:
      jj_consume_token(ADA);
      break;
    case ADD:
      jj_consume_token(ADD);
      break;
    case ADMIN:
      jj_consume_token(ADMIN);
      break;
    case AFTER:
      jj_consume_token(AFTER);
      break;
    case ALWAYS:
      jj_consume_token(ALWAYS);
      break;
    case ASC:
      jj_consume_token(ASC);
      break;
    case ASSERTION:
      jj_consume_token(ASSERTION);
      break;
    case ASSIGNMENT:
      jj_consume_token(ASSIGNMENT);
      break;
    case ATTRIBUTE:
      jj_consume_token(ATTRIBUTE);
      break;
    case ATTRIBUTES:
      jj_consume_token(ATTRIBUTES);
      break;
    case BEFORE:
      jj_consume_token(BEFORE);
      break;
    case BERNOULLI:
      jj_consume_token(BERNOULLI);
      break;
    case BREADTH:
      jj_consume_token(BREADTH);
      break;
    case C:
      jj_consume_token(C);
      break;
    case CASCADE:
      jj_consume_token(CASCADE);
      break;
    case CATALOG:
      jj_consume_token(CATALOG);
      break;
    case CATALOG_NAME:
      jj_consume_token(CATALOG_NAME);
      break;
    case CHAIN:
      jj_consume_token(CHAIN);
      break;
    case CHARACTER_SET_CATALOG:
      jj_consume_token(CHARACTER_SET_CATALOG);
      break;
    case CHARACTER_SET_NAME:
      jj_consume_token(CHARACTER_SET_NAME);
      break;
    case CHARACTER_SET_SCHEMA:
      jj_consume_token(CHARACTER_SET_SCHEMA);
      break;
    case CHARACTERISTICS:
      jj_consume_token(CHARACTERISTICS);
      break;
    case CHARACTERS:
      jj_consume_token(CHARACTERS);
      break;
    case CLASS_ORIGIN:
      jj_consume_token(CLASS_ORIGIN);
      break;
    case COBOL:
      jj_consume_token(COBOL);
      break;
    case COLLATION:
      jj_consume_token(COLLATION);
      break;
    case COLLATION_CATALOG:
      jj_consume_token(COLLATION_CATALOG);
      break;
    case COLLATION_NAME:
      jj_consume_token(COLLATION_NAME);
      break;
    case COLLATION_SCHEMA:
      jj_consume_token(COLLATION_SCHEMA);
      break;
    case COLUMN_NAME:
      jj_consume_token(COLUMN_NAME);
      break;
    case COMMAND_FUNCTION:
      jj_consume_token(COMMAND_FUNCTION);
      break;
    case COMMAND_FUNCTION_CODE:
      jj_consume_token(COMMAND_FUNCTION_CODE);
      break;
    case COMMITTED:
      jj_consume_token(COMMITTED);
      break;
    case CONDITION_NUMBER:
      jj_consume_token(CONDITION_NUMBER);
      break;
    case CONNECTION:
      jj_consume_token(CONNECTION);
      break;
    case CONNECTION_NAME:
      jj_consume_token(CONNECTION_NAME);
      break;
    case CONSTRAINT_CATALOG:
      jj_consume_token(CONSTRAINT_CATALOG);
      break;
    case CONSTRAINT_NAME:
      jj_consume_token(CONSTRAINT_NAME);
      break;
    case CONSTRAINT_SCHEMA:
      jj_consume_token(CONSTRAINT_SCHEMA);
      break;
    case CONSTRAINTS:
      jj_consume_token(CONSTRAINTS);
      break;
    case CONSTRUCTOR:
      jj_consume_token(CONSTRUCTOR);
      break;
    case CONTAINS:
      jj_consume_token(CONTAINS);
      break;
    case CONTINUE:
      jj_consume_token(CONTINUE);
      break;
    case CURSOR_NAME:
      jj_consume_token(CURSOR_NAME);
      break;
    case DATA:
      jj_consume_token(DATA);
      break;
    case DATETIME_INTERVAL_CODE:
      jj_consume_token(DATETIME_INTERVAL_CODE);
      break;
    case DATETIME_INTERVAL_PRECISION:
      jj_consume_token(DATETIME_INTERVAL_PRECISION);
      break;
    case DEFAULTS:
      jj_consume_token(DEFAULTS);
      break;
    case DEFERRABLE:
      jj_consume_token(DEFERRABLE);
      break;
    case DEFERRED:
      jj_consume_token(DEFERRED);
      break;
    case DEFINED:
      jj_consume_token(DEFINED);
      break;
    case DEFINER:
      jj_consume_token(DEFINER);
      break;
    case DEGREE:
      jj_consume_token(DEGREE);
      break;
    case DEPTH:
      jj_consume_token(DEPTH);
      break;
    case DERIVED:
      jj_consume_token(DERIVED);
      break;
    case DESC:
      jj_consume_token(DESC);
      break;
    case DESCRIPTION:
      jj_consume_token(DESCRIPTION);
      break;
    case DESCRIPTOR:
      jj_consume_token(DESCRIPTOR);
      break;
    case DIAGNOSTICS:
      jj_consume_token(DIAGNOSTICS);
      break;
    case DISPATCH:
      jj_consume_token(DISPATCH);
      break;
    case DOMAIN:
      jj_consume_token(DOMAIN);
      break;
    case DYNAMIC_FUNCTION:
      jj_consume_token(DYNAMIC_FUNCTION);
      break;
    case DYNAMIC_FUNCTION_CODE:
      jj_consume_token(DYNAMIC_FUNCTION_CODE);
      break;
    case EQUALS:
      jj_consume_token(EQUALS);
      break;
    case EXCEPTION:
      jj_consume_token(EXCEPTION);
      break;
    case EXCLUDE:
      jj_consume_token(EXCLUDE);
      break;
    case EXCLUDING:
      jj_consume_token(EXCLUDING);
      break;
    case FINAL:
      jj_consume_token(FINAL);
      break;
    case FIRST:
      jj_consume_token(FIRST);
      break;
    case FOLLOWING:
      jj_consume_token(FOLLOWING);
      break;
    case FORTRAN:
      jj_consume_token(FORTRAN);
      break;
    case FOUND:
      jj_consume_token(FOUND);
      break;
    case G:
      jj_consume_token(G);
      break;
    case GENERAL:
      jj_consume_token(GENERAL);
      break;
    case GENERATED:
      jj_consume_token(GENERATED);
      break;
    case GO:
      jj_consume_token(GO);
      break;
    case GOTO:
      jj_consume_token(GOTO);
      break;
    case GRANTED:
      jj_consume_token(GRANTED);
      break;
    case HIERARCHY:
      jj_consume_token(HIERARCHY);
      break;
    case IMMEDIATE:
      jj_consume_token(IMMEDIATE);
      break;
    case IMPLEMENTATION:
      jj_consume_token(IMPLEMENTATION);
      break;
    case INCLUDING:
      jj_consume_token(INCLUDING);
      break;
    case INCREMENT:
      jj_consume_token(INCREMENT);
      break;
    case INITIALLY:
      jj_consume_token(INITIALLY);
      break;
    case INPUT:
      jj_consume_token(INPUT);
      break;
    case INSTANCE:
      jj_consume_token(INSTANCE);
      break;
    case INSTANTIABLE:
      jj_consume_token(INSTANTIABLE);
      break;
    case INVOKER:
      jj_consume_token(INVOKER);
      break;
    case ISOLATION:
      jj_consume_token(ISOLATION);
      break;
    case JAVA:
      jj_consume_token(JAVA);
      break;
    case K:
      jj_consume_token(K);
      break;
    case KEY:
      jj_consume_token(KEY);
      break;
    case KEY_MEMBER:
      jj_consume_token(KEY_MEMBER);
      break;
    case KEY_TYPE:
      jj_consume_token(KEY_TYPE);
      break;
    case LABEL:
      jj_consume_token(LABEL);
      break;
    case LAST:
      jj_consume_token(LAST);
      break;
    case LENGTH:
      jj_consume_token(LENGTH);
      break;
    case LEVEL:
      jj_consume_token(LEVEL);
      break;
    case LIBRARY:
      jj_consume_token(LIBRARY);
      break;
    case LOCATOR:
      jj_consume_token(LOCATOR);
      break;
    case M:
      jj_consume_token(M);
      break;
    case MAP:
      jj_consume_token(MAP);
      break;
    case MATCHED:
      jj_consume_token(MATCHED);
      break;
    case MAXVALUE:
      jj_consume_token(MAXVALUE);
      break;
    case MESSAGE_LENGTH:
      jj_consume_token(MESSAGE_LENGTH);
      break;
    case MESSAGE_OCTET_LENGTH:
      jj_consume_token(MESSAGE_OCTET_LENGTH);
      break;
    case MESSAGE_TEXT:
      jj_consume_token(MESSAGE_TEXT);
      break;
    case MINVALUE:
      jj_consume_token(MINVALUE);
      break;
    case MORE_KW:
      jj_consume_token(MORE_KW);
      break;
    case MUMPS:
      jj_consume_token(MUMPS);
      break;
    case NAME:
      jj_consume_token(NAME);
      break;
    case NAMES:
      jj_consume_token(NAMES);
      break;
    case NESTING:
      jj_consume_token(NESTING);
      break;
    case NEXT:
      jj_consume_token(NEXT);
      break;
    case NORMALIZED:
      jj_consume_token(NORMALIZED);
      break;
    case NULLABLE:
      jj_consume_token(NULLABLE);
      break;
    case NULLS:
      jj_consume_token(NULLS);
      break;
    case NUMBER:
      jj_consume_token(NUMBER);
      break;
    case OBJECT:
      jj_consume_token(OBJECT);
      break;
    case OCTETS:
      jj_consume_token(OCTETS);
      break;
    case OPTION:
      jj_consume_token(OPTION);
      break;
    case OPTIONS:
      jj_consume_token(OPTIONS);
      break;
    case ORDERING:
      jj_consume_token(ORDERING);
      break;
    case ORDINALITY:
      jj_consume_token(ORDINALITY);
      break;
    case OTHERS:
      jj_consume_token(OTHERS);
      break;
    case OUTPUT:
      jj_consume_token(OUTPUT);
      break;
    case OVERRIDING:
      jj_consume_token(OVERRIDING);
      break;
    case PAD:
      jj_consume_token(PAD);
      break;
    case PARAMETER_MODE:
      jj_consume_token(PARAMETER_MODE);
      break;
    case PARAMETER_NAME:
      jj_consume_token(PARAMETER_NAME);
      break;
    case PARAMETER_ORDINAL_POSITION:
      jj_consume_token(PARAMETER_ORDINAL_POSITION);
      break;
    case PARAMETER_SPECIFIC_CATALOG:
      jj_consume_token(PARAMETER_SPECIFIC_CATALOG);
      break;
    case PARAMETER_SPECIFIC_NAME:
      jj_consume_token(PARAMETER_SPECIFIC_NAME);
      break;
    case PARAMETER_SPECIFIC_SCHEMA:
      jj_consume_token(PARAMETER_SPECIFIC_SCHEMA);
      break;
    case PARTIAL:
      jj_consume_token(PARTIAL);
      break;
    case PASCAL:
      jj_consume_token(PASCAL);
      break;
    case PASSTHROUGH:
      jj_consume_token(PASSTHROUGH);
      break;
    case PATH:
      jj_consume_token(PATH);
      break;
    case PLACING:
      jj_consume_token(PLACING);
      break;
    case PLAN:
      jj_consume_token(PLAN);
      break;
    case PLI:
      jj_consume_token(PLI);
      break;
    case PRECEDING:
      jj_consume_token(PRECEDING);
      break;
    case PRESERVE:
      jj_consume_token(PRESERVE);
      break;
    case PRIOR:
      jj_consume_token(PRIOR);
      break;
    case PRIVILEGES:
      jj_consume_token(PRIVILEGES);
      break;
    case PUBLIC:
      jj_consume_token(PUBLIC);
      break;
    case READ:
      jj_consume_token(READ);
      break;
    case RELATIVE:
      jj_consume_token(RELATIVE);
      break;
    case REPEATABLE:
      jj_consume_token(REPEATABLE);
      break;
    case RESTART:
      jj_consume_token(RESTART);
      break;
    case RESTRICT:
      jj_consume_token(RESTRICT);
      break;
    case RETURNED_CARDINALITY:
      jj_consume_token(RETURNED_CARDINALITY);
      break;
    case RETURNED_LENGTH:
      jj_consume_token(RETURNED_LENGTH);
      break;
    case RETURNED_OCTET_LENGTH:
      jj_consume_token(RETURNED_OCTET_LENGTH);
      break;
    case RETURNED_SQLSTATE:
      jj_consume_token(RETURNED_SQLSTATE);
      break;
    case ROLE:
      jj_consume_token(ROLE);
      break;
    case ROUTINE:
      jj_consume_token(ROUTINE);
      break;
    case ROUTINE_CATALOG:
      jj_consume_token(ROUTINE_CATALOG);
      break;
    case ROUTINE_NAME:
      jj_consume_token(ROUTINE_NAME);
      break;
    case ROUTINE_SCHEMA:
      jj_consume_token(ROUTINE_SCHEMA);
      break;
    case ROW_COUNT:
      jj_consume_token(ROW_COUNT);
      break;
    case SCALE:
      jj_consume_token(SCALE);
      break;
    case SCHEMA:
      jj_consume_token(SCHEMA);
      break;
    case SCHEMA_NAME:
      jj_consume_token(SCHEMA_NAME);
      break;
    case SCOPE_CATALOGS:
      jj_consume_token(SCOPE_CATALOGS);
      break;
    case SCOPE_NAME:
      jj_consume_token(SCOPE_NAME);
      break;
    case SCOPE_SCHEMA:
      jj_consume_token(SCOPE_SCHEMA);
      break;
    case SECTION:
      jj_consume_token(SECTION);
      break;
    case SECURITY:
      jj_consume_token(SECURITY);
      break;
    case SELF:
      jj_consume_token(SELF);
      break;
    case SEQUENCE:
      jj_consume_token(SEQUENCE);
      break;
    case SERIALIZABLE:
      jj_consume_token(SERIALIZABLE);
      break;
    case SERVER:
      jj_consume_token(SERVER);
      break;
    case SERVER_NAME:
      jj_consume_token(SERVER_NAME);
      break;
    case SESSION:
      jj_consume_token(SESSION);
      break;
    case SETS:
      jj_consume_token(SETS);
      break;
    case SIMPLE:
      jj_consume_token(SIMPLE);
      break;
    case SIZE:
      jj_consume_token(SIZE);
      break;
    case SOURCE:
      jj_consume_token(SOURCE);
      break;
    case SPACE:
      jj_consume_token(SPACE);
      break;
    case SPECIFIC_NAME:
      jj_consume_token(SPECIFIC_NAME);
      break;
    case STATE:
      jj_consume_token(STATE);
      break;
    case STATEMENT:
      jj_consume_token(STATEMENT);
      break;
    case STRUCTURE:
      jj_consume_token(STRUCTURE);
      break;
    case STYLE:
      jj_consume_token(STYLE);
      break;
    case SUBCLASS_ORIGIN:
      jj_consume_token(SUBCLASS_ORIGIN);
      break;
    case SUBSTITUTE:
      jj_consume_token(SUBSTITUTE);
      break;
    case TABLE_NAME:
      jj_consume_token(TABLE_NAME);
      break;
    case TEMPORARY:
      jj_consume_token(TEMPORARY);
      break;
    case TIES:
      jj_consume_token(TIES);
      break;
    case TOP_LEVEL_COUNT:
      jj_consume_token(TOP_LEVEL_COUNT);
      break;
    case TRANSACTION:
      jj_consume_token(TRANSACTION);
      break;
    case TRANSACTIONS_ACTIVE:
      jj_consume_token(TRANSACTIONS_ACTIVE);
      break;
    case TRANSACTIONS_COMMITTED:
      jj_consume_token(TRANSACTIONS_COMMITTED);
      break;
    case TRANSACTIONS_ROLLED_BACK:
      jj_consume_token(TRANSACTIONS_ROLLED_BACK);
      break;
    case TRANSFORM:
      jj_consume_token(TRANSFORM);
      break;
    case TRANSFORMS:
      jj_consume_token(TRANSFORMS);
      break;
    case TRIGGER_CATALOG:
      jj_consume_token(TRIGGER_CATALOG);
      break;
    case TRIGGER_NAME:
      jj_consume_token(TRIGGER_NAME);
      break;
    case TRIGGER_SCHEMA:
      jj_consume_token(TRIGGER_SCHEMA);
      break;
    case TYPE:
      jj_consume_token(TYPE);
      break;
    case UNBOUNDED:
      jj_consume_token(UNBOUNDED);
      break;
    case UNCOMMITTED:
      jj_consume_token(UNCOMMITTED);
      break;
    case UNDER:
      jj_consume_token(UNDER);
      break;
    case UNNAMED:
      jj_consume_token(UNNAMED);
      break;
    case USAGE:
      jj_consume_token(USAGE);
      break;
    case USER_DEFINED_TYPE_CATALOG:
      jj_consume_token(USER_DEFINED_TYPE_CATALOG);
      break;
    case USER_DEFINED_TYPE_CODE:
      jj_consume_token(USER_DEFINED_TYPE_CODE);
      break;
    case USER_DEFINED_TYPE_NAME:
      jj_consume_token(USER_DEFINED_TYPE_NAME);
      break;
    case USER_DEFINED_TYPE_SCHEMA:
      jj_consume_token(USER_DEFINED_TYPE_SCHEMA);
      break;
    case VERSION:
      jj_consume_token(VERSION);
      break;
    case VIEW:
      jj_consume_token(VIEW);
      break;
    case WRAPPER:
      jj_consume_token(WRAPPER);
      break;
    case WORK:
      jj_consume_token(WORK);
      break;
    case WRITE:
      jj_consume_token(WRITE);
      break;
    case XML:
      jj_consume_token(XML);
      break;
    case ZONE:
      jj_consume_token(ZONE);
      break;
    default:
      jj_la1[172] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return getToken(0).image.toUpperCase();}
    throw new Error("Missing return statement in function");
  }

/**
 * Defines a production which can never be accepted by the parser.
 * In effect, it tells the parser, "If you got here, you've gone too far."
 * It is used as the default production for parser extension points;
 * derived parsers replace it with a real production when they want to
 * implement a particular extension point.
 */
  final public void UnusedExtension() throws ParseException {
    if (false) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(ZONE);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_3R_115() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    }
    }
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) return true;
    }
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_scan_token(SYMMETRIC)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) return true;
    }
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_3R_121()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(BETWEEN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_33()) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(BETWEEN)) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_scan_token(SUBSTRING)) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_scan_token(UESCAPE)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(UNICODE_QUOTED_IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(HOOK)) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_147() {
    Token xsp;
    if (jj_3_27()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_27()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_19()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_69()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(CROSS)) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(MINUTE)) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(FULL)) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_scan_token(RIGHT)) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(LEFT)) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(MINUTE)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_scan_token(TO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(INNER)) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(HOUR)) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(JOIN)) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(SPECIFIC)) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_138() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_170()) jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    xsp = jj_scanpos;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3_42()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_26() {
    return false;
  }

  private boolean jj_3_35() {
    if (jj_scan_token(TO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) return true;
    }
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(NATURAL)) return true;
    return false;
  }

  private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = true;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_24()) return true;
    }
    return false;
  }

  private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_34() {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(MONTH)) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) return true;
    }
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(INTERVAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_213()) jj_scanpos = xsp;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_3R_217()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_119()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_145()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_60()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_3R_216()) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_3R_215()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_22()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_scan_token(MULTISET)) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_146()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_scan_token(LEADING)) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_scan_token(MULTISET)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) return true;
    }
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_scan_token(TRAILING)) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_122() {
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(BOTH)) return true;
    return false;
  }

  private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    }
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(DATE)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    jj_lookingAhead = true;
    jj_semLA = false;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_122()) return true;
    if (jj_scan_token(ZONE)) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_scan_token(LBRACE_TS)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(TRIM)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_scan_token(LBRACE_T)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(ORDER)) return true;
    return false;
  }

  private boolean jj_3R_181() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(LBRACE_D)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_scan_token(SUBSTRING)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_111() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) return true;
    }
    if (jj_3R_183()) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(FLOOR)) return true;
    if (jj_3R_183()) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_scan_token(UESCAPE)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(OVERLAY)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_scan_token(MATCHED)) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_scan_token(TRANSLATE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_scan_token(UNICODE_STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(PREFIXED_STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_202() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_scan_token(527)) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_222()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_223()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(CONVERT)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(POSITION)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(BINARY_STRING_LITERAL)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_219()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(EXTRACT)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(CAST)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3_40()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_180() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_3R_218()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_218()) return true;
    return false;
  }

  private boolean jj_3R_178() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_218()) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(CURSOR)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(APPROX_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_3R_23()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_scan_token(DECIMAL_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_218() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_scan_token(UNSIGNED_INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_3R_182()) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_3R_181()) return true;
    return false;
  }

  private boolean jj_3R_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_3R_180()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_scan_token(GROUP)) return true;
    if (jj_scan_token(BY)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_3R_179()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(A)) return true;
    return false;
  }

  private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_3R_178()) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_scan_token(IS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_scan_token(EXISTS)) return true;
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(WHEN)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(SUBMULTISET)) return true;
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(MEMBER)) return true;
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(DISTINCT)) return true;
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(OR)) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(AND)) return true;
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(CONCAT)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(425)) jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_scan_token(CASE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_141()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(390)) jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_3R_139()) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(ROW)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3_17()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3_45()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_177() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) return true;
    }
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_scan_token(ALL)) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_134()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(EXCEPT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_176() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) return true;
    }
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(ALL)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_214()) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(INTERSECT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) return true;
    }
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(ALL)) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_scan_token(UNION)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(MULTISET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(VALUES)) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(EXCEPT)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(WITH)) return true;
    if (jj_scan_token(TYPE)) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(INTERSECT)) return true;
    return false;
  }

  private boolean jj_3R_34() {
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_scan_token(TABLE)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3R_174() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_3R_184()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(INSERT)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_scan_token(ROW)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_scan_token(LBRACE_FN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_3R_125()) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_scan_token(ROW)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(1)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(8)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) {
    jj_scanpos = xsp;
    if (jj_scan_token(134)) {
    jj_scanpos = xsp;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_scan_token(139)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) {
    jj_scanpos = xsp;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_scan_token(150)) {
    jj_scanpos = xsp;
    if (jj_scan_token(154)) {
    jj_scanpos = xsp;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(166)) {
    jj_scanpos = xsp;
    if (jj_scan_token(167)) {
    jj_scanpos = xsp;
    if (jj_scan_token(178)) {
    jj_scanpos = xsp;
    if (jj_scan_token(179)) {
    jj_scanpos = xsp;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(193)) {
    jj_scanpos = xsp;
    if (jj_scan_token(194)) {
    jj_scanpos = xsp;
    if (jj_scan_token(195)) {
    jj_scanpos = xsp;
    if (jj_scan_token(198)) {
    jj_scanpos = xsp;
    if (jj_scan_token(199)) {
    jj_scanpos = xsp;
    if (jj_scan_token(201)) {
    jj_scanpos = xsp;
    if (jj_scan_token(205)) {
    jj_scanpos = xsp;
    if (jj_scan_token(209)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) {
    jj_scanpos = xsp;
    if (jj_scan_token(214)) {
    jj_scanpos = xsp;
    if (jj_scan_token(215)) {
    jj_scanpos = xsp;
    if (jj_scan_token(216)) {
    jj_scanpos = xsp;
    if (jj_scan_token(219)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(223)) {
    jj_scanpos = xsp;
    if (jj_scan_token(230)) {
    jj_scanpos = xsp;
    if (jj_scan_token(232)) {
    jj_scanpos = xsp;
    if (jj_scan_token(233)) {
    jj_scanpos = xsp;
    if (jj_scan_token(235)) {
    jj_scanpos = xsp;
    if (jj_scan_token(236)) {
    jj_scanpos = xsp;
    if (jj_scan_token(237)) {
    jj_scanpos = xsp;
    if (jj_scan_token(238)) {
    jj_scanpos = xsp;
    if (jj_scan_token(239)) {
    jj_scanpos = xsp;
    if (jj_scan_token(242)) {
    jj_scanpos = xsp;
    if (jj_scan_token(247)) {
    jj_scanpos = xsp;
    if (jj_scan_token(248)) {
    jj_scanpos = xsp;
    if (jj_scan_token(249)) {
    jj_scanpos = xsp;
    if (jj_scan_token(256)) {
    jj_scanpos = xsp;
    if (jj_scan_token(258)) {
    jj_scanpos = xsp;
    if (jj_scan_token(259)) {
    jj_scanpos = xsp;
    if (jj_scan_token(261)) {
    jj_scanpos = xsp;
    if (jj_scan_token(263)) {
    jj_scanpos = xsp;
    if (jj_scan_token(266)) {
    jj_scanpos = xsp;
    if (jj_scan_token(267)) {
    jj_scanpos = xsp;
    if (jj_scan_token(268)) {
    jj_scanpos = xsp;
    if (jj_scan_token(272)) {
    jj_scanpos = xsp;
    if (jj_scan_token(277)) {
    jj_scanpos = xsp;
    if (jj_scan_token(279)) {
    jj_scanpos = xsp;
    if (jj_scan_token(280)) {
    jj_scanpos = xsp;
    if (jj_scan_token(281)) {
    jj_scanpos = xsp;
    if (jj_scan_token(286)) {
    jj_scanpos = xsp;
    if (jj_scan_token(288)) {
    jj_scanpos = xsp;
    if (jj_scan_token(292)) {
    jj_scanpos = xsp;
    if (jj_scan_token(295)) {
    jj_scanpos = xsp;
    if (jj_scan_token(297)) {
    jj_scanpos = xsp;
    if (jj_scan_token(298)) {
    jj_scanpos = xsp;
    if (jj_scan_token(300)) {
    jj_scanpos = xsp;
    if (jj_scan_token(302)) {
    jj_scanpos = xsp;
    if (jj_scan_token(308)) {
    jj_scanpos = xsp;
    if (jj_scan_token(309)) {
    jj_scanpos = xsp;
    if (jj_scan_token(312)) {
    jj_scanpos = xsp;
    if (jj_scan_token(313)) {
    jj_scanpos = xsp;
    if (jj_scan_token(314)) {
    jj_scanpos = xsp;
    if (jj_scan_token(317)) {
    jj_scanpos = xsp;
    if (jj_scan_token(321)) {
    jj_scanpos = xsp;
    if (jj_scan_token(322)) {
    jj_scanpos = xsp;
    if (jj_scan_token(324)) {
    jj_scanpos = xsp;
    if (jj_scan_token(325)) {
    jj_scanpos = xsp;
    if (jj_scan_token(326)) {
    jj_scanpos = xsp;
    if (jj_scan_token(327)) {
    jj_scanpos = xsp;
    if (jj_scan_token(328)) {
    jj_scanpos = xsp;
    if (jj_scan_token(329)) {
    jj_scanpos = xsp;
    if (jj_scan_token(330)) {
    jj_scanpos = xsp;
    if (jj_scan_token(332)) {
    jj_scanpos = xsp;
    if (jj_scan_token(333)) {
    jj_scanpos = xsp;
    if (jj_scan_token(334)) {
    jj_scanpos = xsp;
    if (jj_scan_token(338)) {
    jj_scanpos = xsp;
    if (jj_scan_token(339)) {
    jj_scanpos = xsp;
    if (jj_scan_token(340)) {
    jj_scanpos = xsp;
    if (jj_scan_token(343)) {
    jj_scanpos = xsp;
    if (jj_scan_token(346)) {
    jj_scanpos = xsp;
    if (jj_scan_token(348)) {
    jj_scanpos = xsp;
    if (jj_scan_token(349)) {
    jj_scanpos = xsp;
    if (jj_scan_token(351)) {
    jj_scanpos = xsp;
    if (jj_scan_token(354)) {
    jj_scanpos = xsp;
    if (jj_scan_token(369)) {
    jj_scanpos = xsp;
    if (jj_scan_token(371)) {
    jj_scanpos = xsp;
    if (jj_scan_token(372)) {
    jj_scanpos = xsp;
    if (jj_scan_token(373)) {
    jj_scanpos = xsp;
    if (jj_scan_token(376)) {
    jj_scanpos = xsp;
    if (jj_scan_token(377)) {
    jj_scanpos = xsp;
    if (jj_scan_token(378)) {
    jj_scanpos = xsp;
    if (jj_scan_token(379)) {
    jj_scanpos = xsp;
    if (jj_scan_token(383)) {
    jj_scanpos = xsp;
    if (jj_scan_token(386)) {
    jj_scanpos = xsp;
    if (jj_scan_token(387)) {
    jj_scanpos = xsp;
    if (jj_scan_token(388)) {
    jj_scanpos = xsp;
    if (jj_scan_token(389)) {
    jj_scanpos = xsp;
    if (jj_scan_token(391)) {
    jj_scanpos = xsp;
    if (jj_scan_token(395)) {
    jj_scanpos = xsp;
    if (jj_scan_token(396)) {
    jj_scanpos = xsp;
    if (jj_scan_token(397)) {
    jj_scanpos = xsp;
    if (jj_scan_token(399)) {
    jj_scanpos = xsp;
    if (jj_scan_token(400)) {
    jj_scanpos = xsp;
    if (jj_scan_token(401)) {
    jj_scanpos = xsp;
    if (jj_scan_token(405)) {
    jj_scanpos = xsp;
    if (jj_scan_token(406)) {
    jj_scanpos = xsp;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(410)) {
    jj_scanpos = xsp;
    if (jj_scan_token(411)) {
    jj_scanpos = xsp;
    if (jj_scan_token(412)) {
    jj_scanpos = xsp;
    if (jj_scan_token(413)) {
    jj_scanpos = xsp;
    if (jj_scan_token(414)) {
    jj_scanpos = xsp;
    if (jj_scan_token(417)) {
    jj_scanpos = xsp;
    if (jj_scan_token(419)) {
    jj_scanpos = xsp;
    if (jj_scan_token(420)) {
    jj_scanpos = xsp;
    if (jj_scan_token(423)) {
    jj_scanpos = xsp;
    if (jj_scan_token(424)) {
    jj_scanpos = xsp;
    if (jj_scan_token(426)) {
    jj_scanpos = xsp;
    if (jj_scan_token(434)) {
    jj_scanpos = xsp;
    if (jj_scan_token(435)) {
    jj_scanpos = xsp;
    if (jj_scan_token(439)) {
    jj_scanpos = xsp;
    if (jj_scan_token(440)) {
    jj_scanpos = xsp;
    if (jj_scan_token(441)) {
    jj_scanpos = xsp;
    if (jj_scan_token(444)) {
    jj_scanpos = xsp;
    if (jj_scan_token(450)) {
    jj_scanpos = xsp;
    if (jj_scan_token(452)) {
    jj_scanpos = xsp;
    if (jj_scan_token(454)) {
    jj_scanpos = xsp;
    if (jj_scan_token(461)) {
    jj_scanpos = xsp;
    if (jj_scan_token(463)) {
    jj_scanpos = xsp;
    if (jj_scan_token(464)) {
    jj_scanpos = xsp;
    if (jj_scan_token(465)) {
    jj_scanpos = xsp;
    if (jj_scan_token(466)) {
    jj_scanpos = xsp;
    if (jj_scan_token(467)) {
    jj_scanpos = xsp;
    if (jj_scan_token(468)) {
    jj_scanpos = xsp;
    if (jj_scan_token(473)) {
    jj_scanpos = xsp;
    if (jj_scan_token(474)) {
    jj_scanpos = xsp;
    if (jj_scan_token(475)) {
    jj_scanpos = xsp;
    if (jj_scan_token(478)) {
    jj_scanpos = xsp;
    if (jj_scan_token(480)) {
    jj_scanpos = xsp;
    if (jj_scan_token(481)) {
    jj_scanpos = xsp;
    if (jj_scan_token(482)) {
    jj_scanpos = xsp;
    if (jj_scan_token(486)) {
    jj_scanpos = xsp;
    if (jj_scan_token(490)) {
    jj_scanpos = xsp;
    if (jj_scan_token(492)) {
    jj_scanpos = xsp;
    if (jj_scan_token(493)) {
    jj_scanpos = xsp;
    if (jj_scan_token(494)) {
    jj_scanpos = xsp;
    if (jj_scan_token(495)) {
    jj_scanpos = xsp;
    if (jj_scan_token(504)) {
    jj_scanpos = xsp;
    if (jj_scan_token(505)) {
    jj_scanpos = xsp;
    if (jj_scan_token(515)) {
    jj_scanpos = xsp;
    if (jj_scan_token(514)) {
    jj_scanpos = xsp;
    if (jj_scan_token(516)) {
    jj_scanpos = xsp;
    if (jj_scan_token(517)) {
    jj_scanpos = xsp;
    if (jj_scan_token(519)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(254)) {
    jj_scanpos = xsp;
    if (jj_scan_token(255)) {
    jj_scanpos = xsp;
    if (jj_scan_token(415)) {
    jj_scanpos = xsp;
    if (jj_scan_token(448)) {
    jj_scanpos = xsp;
    if (jj_scan_token(491)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(SELECT)) return true;
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_148() {
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_22()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_67()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_46()) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_scan_token(ESCAPE)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(SIMILAR)) return true;
    if (jj_scan_token(TO)) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(SIMILAR)) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(2)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(136)) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) {
    jj_scanpos = xsp;
    if (jj_scan_token(180)) {
    jj_scanpos = xsp;
    if (jj_scan_token(192)) {
    jj_scanpos = xsp;
    if (jj_scan_token(243)) {
    jj_scanpos = xsp;
    if (jj_scan_token(252)) {
    jj_scanpos = xsp;
    if (jj_scan_token(254)) {
    jj_scanpos = xsp;
    if (jj_scan_token(255)) {
    jj_scanpos = xsp;
    if (jj_scan_token(257)) {
    jj_scanpos = xsp;
    if (jj_scan_token(262)) {
    jj_scanpos = xsp;
    if (jj_scan_token(270)) {
    jj_scanpos = xsp;
    if (jj_scan_token(273)) {
    jj_scanpos = xsp;
    if (jj_scan_token(296)) {
    jj_scanpos = xsp;
    if (jj_scan_token(301)) {
    jj_scanpos = xsp;
    if (jj_scan_token(335)) {
    jj_scanpos = xsp;
    if (jj_scan_token(342)) {
    jj_scanpos = xsp;
    if (jj_scan_token(353)) {
    jj_scanpos = xsp;
    if (jj_scan_token(392)) {
    jj_scanpos = xsp;
    if (jj_scan_token(432)) {
    jj_scanpos = xsp;
    if (jj_scan_token(437)) {
    jj_scanpos = xsp;
    if (jj_scan_token(438)) {
    jj_scanpos = xsp;
    if (jj_scan_token(445)) {
    jj_scanpos = xsp;
    if (jj_scan_token(489)) {
    jj_scanpos = xsp;
    if (jj_scan_token(499)) {
    jj_scanpos = xsp;
    if (jj_scan_token(500)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_scan_token(NOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) return true;
    }
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_22()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SqlParserImplTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[173];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static private int[] jj_la1_11;
  static private int[] jj_la1_12;
  static private int[] jj_la1_13;
  static private int[] jj_la1_14;
  static private int[] jj_la1_15;
  static private int[] jj_la1_16;
  static private int[] jj_la1_17;
  static private int[] jj_la1_18;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
      jj_la1_init_7();
      jj_la1_init_8();
      jj_la1_init_9();
      jj_la1_init_10();
      jj_la1_init_11();
      jj_la1_init_12();
      jj_la1_init_13();
      jj_la1_init_14();
      jj_la1_init_15();
      jj_la1_init_16();
      jj_la1_init_17();
      jj_la1_init_18();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x200,0x0,0x40000,0x0,0x0,0x200,0x0,0x0,0x40000,0x4c6c11fa,0x40000,0x4c6c11fa,0x0,0x40000,0x4c6c11fa,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x4c6c11fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x4c6c11fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c6811fa,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x800000,0x800000,0x800000,0x800000,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c6811fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c6811fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c6811fa,0x4c6811fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c6811fa,0x0,0x4c6811fa,0x0,0x6c6811fe,0x20000004,0x0,0x6c6811fe,0x0,0x200,0x200,0x200,0x200,0x200,0x200,0x0,0x200,0x200,0x200,0x200,0x200,0x200,0x0,0x4000,0x0,0x0,0x0,0x0,0x2,0x4c6811fa,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84c4501,0x0,0xf84c4501,0x0,0x0,0xf84c4501,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84c4501,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84c4501,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84c4501,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84d4501,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84c4501,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x2800000,0x0,0x0,0x0,0x0,0xfacc454d,0xfacc454d,0x0,0x300000,0x0,0x0,0x0,0x80,0x80,0x0,0x320000,0x0,0x0,0xf84c4501,0x0,0xf84c4501,0x0,0xfd4c6501,0x5002000,0x0,0xfd4c6501,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf84c4501,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0x0,0xbf6ae7a2,0x0,0x0,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,0xbf6ae7a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0xbf6ae7a2,0x0,0xbf6ae7a2,0x0,0xbf6aefb2,0x810,0x0,0xbf6aefb2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf6ae7a2,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a00000,0x0,0x6a00000,0x0,0x0,0x6a00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a00000,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x6a00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a00000,0x0,0x0,0x0,0x1000200,0x0,0x0,0x0,0x0,0x0,0x1000200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x100000,0x0,0x0,0x0,0x1000000,0x0,0x6abfc00,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x6a00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,0x67a00000,0x67a00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a00000,0x0,0x6a00000,0x0,0x6a30904,0x30904,0xbfc00,0x6a30904,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a00000,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x200000,0x200000,0x0,0x80,0x200000,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,0x0,0xc52ea7e,0x0,0x0,0xc52ea7e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,0x0,0x0,0x0,0x0,0x0,0x40000,0x40000,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0xc52ea7e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcd2ea7e,0xcd2ea7e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,0x0,0xc52ea7e,0x0,0x2c52eb7e,0x20000100,0x0,0x2c52eb7e,0x0,0x200000,0x200000,0x200000,0x200000,0x200000,0x200000,0x0,0x200000,0x200000,0x200000,0x200000,0x200000,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc52ea7e,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x80,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0xc8c00e2,0x0,0xc8c00e2,0x0,0x0,0xc8c00e2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8c00e2,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0xc8c00e2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8c00e2,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x800000,0x800000,0x8000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x8000,0x0,0xc8c00e2,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8c00e2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcac00e2,0xcac00e2,0x1000000,0x0,0x20000000,0x1000000,0x1000000,0x0,0x0,0x20000000,0x404000,0x0,0x0,0xc8c00e2,0x0,0xc8c00e2,0x0,0xc9c08e2,0x100800,0x0,0xc9c08e2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x400,0x8000,0x8000,0x8000,0xc8c00e2,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x400000,0x0,0x20000000,0x0,0x0,0x400000,0x0,0x0,0xc9c622ce,0x0,0xc9c622ce,0x0,0x0,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x1000,0x0,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9c622ce,0xc9c622ce,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9c622ce,0x0,0xc9c622ce,0x0,0xc9c622cf,0x1,0x0,0xe9c622cf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9c622ce,};
   }
   private static void jj_la1_init_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x384fb40,0x0,0x384fb40,0x0,0x0,0x384fb40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x384fb40,0x0,0x0,0x0,0x0,0x0,0x400400,0x0,0x100000,0x100000,0x0,0x0,0x384fb40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x384fb40,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x4000000,0x4000000,0x80,0x4000080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0xc384fb40,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x384fb40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x384fb43,0x384fb53,0x0,0x0,0x0,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x0,0x384fb40,0x0,0x384fb40,0x0,0xd38cfb40,0xd0080000,0xc0000000,0xd38cfb40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x80,0x0,0x0,0x0,0x0,0x384fb40,};
   }
   private static void jj_la1_init_8() {
      jj_la1_8 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x43a11cad,0x0,0x43a11cad,0x0,0x0,0x43a11cad,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43a11cad,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43a11cad,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43a11cad,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400100,0x0,0x108000,0x108000,0x0,0x0,0x0,0x0,0x0,0x400000,0xc3a11cad,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x108000,0x108000,0x0,0x43a11cad,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x43e11cad,0x43e11cad,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43a11cad,0x0,0x43a11cad,0x0,0x43a35cef,0x24042,0x0,0x43a35cef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400100,0x0,0x0,0x0,0x0,0x43a11cad,};
   }
   private static void jj_la1_init_9() {
      jj_la1_9 = new int[] {0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27305691,0x0,0x27305691,0x0,0x0,0x27305691,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27305691,0x0,0x0,0x10000000,0x10000000,0x10000000,0x0,0x20000,0x0,0x0,0x0,0x0,0x27305691,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27305691,0x0,0x800000,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x20,0x0,0x20,0x20,0x0,0x400020,0x0,0x80000000,0x80000000,0x0,0x20,0x0,0x0,0x40,0x0,0x27305691,0x40,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27305691,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x27305e91,0x27305e91,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27305691,0x40000000,0x27305691,0x40000000,0x27307791,0x2100,0x0,0x27307791,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x20,0x40,0x40,0x60,0x27305691,};
   }
   private static void jj_la1_init_10() {
      jj_la1_10 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,0x0,0xb49c77f6,0x0,0x0,0xb49c77f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0xb49c77f6,0xb49c77f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200001,0x0,0x0,0xb49c77f6,0x0,0xb49c77f6,0x0,0xb4dcf7f6,0x408000,0x0,0xb4dcf7f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb49c77f6,};
   }
   private static void jj_la1_init_11() {
      jj_la1_11 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x8f3a0004,0x0,0x0,0x8f3a0004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0014,0x8f3a0014,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,0x0,0x8f3a0004,0x0,0x8f3a0006,0x2,0x0,0x8f3a0006,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8f3a0004,};
   }
   private static void jj_la1_init_12() {
      jj_la1_12 = new int[] {0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7d63b8bc,0x0,0x7d63b8bc,0x0,0x0,0x7d63b8bc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7d63b8bc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7d63b8bc,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x7d63b8bc,0x0,0x0,0x200,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x100000,0x100000,0x0,0x40,0x0,0x0,0x0,0x0,0xfd63b8bc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x7d63b8bc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7d63b8bc,0x7d63b8bc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7d63b8bc,0x0,0x7d63b8bc,0x0,0x7d63b9bc,0x100,0x80000000,0x7d63b9bc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7d63b8bc,};
   }
   private static void jj_la1_init_13() {
      jj_la1_13 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x138c059a,0x0,0x138c059a,0x0,0x0,0x138c059a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x138c059a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x138c059a,0x80000000,0x0,0x90000000,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x138c059a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x40000000,0x40000000,0x0,0x4,0x4,0x4,0x0,0x4000004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x138c059a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x138c059a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x138c05ba,0x138c05ba,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x200,0x0,0x138c059a,0x0,0x138c059a,0x0,0x33ed059a,0x20610000,0x0,0x3bed059a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x138c059a,};
   }
   private static void jj_la1_init_14() {
      jj_la1_14 = new int[] {0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e1fa054,0x0,0x4e1fa054,0x0,0x0,0x4e1fa054,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e1fa054,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x4e1fa054,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x4e1fa054,0x0,0x0,0x0,0x20000180,0x0,0x0,0x0,0x0,0x0,0x20000180,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000180,0x0,0x4e1fa055,0x20000180,0x0,0x0,0x20000000,0x0,0x0,0x0,0x80000000,0x0,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x4e1fa054,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e1fa9d4,0x4e1fa9d4,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x0,0x10200000,0x0,0x0,0x4e1fa054,0x0,0x4e1fa054,0x0,0x4e1fa054,0x0,0x1,0x4e1fa054,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x20000000,0x4e1fa054,};
   }
   private static void jj_la1_init_15() {
      jj_la1_15 = new int[] {0x0,0x40000,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x80000000,0x0,0x0,0x0,0x0,0x300f447,0x0,0x300f447,0x0,0x0,0x300f447,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x300f447,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x80,0x0,0x0,0x300f447,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x40000000,0x300f447,0x0,0x0,0x0,0x21,0x0,0x0,0x0,0x0,0x0,0x21,0x0,0x8,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x20,0x0,0x300fc47,0x20,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300f447,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x800000,0x0,0x360f447,0x360f447,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300f447,0x0,0x300f447,0x0,0x318f647,0x180200,0x800,0x318f647,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x20,0x20,0x20,0x300f447,};
   }
   private static void jj_la1_init_16() {
      jj_la1_16 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x100000,0x0,0xbc,0x0,0xbc,0x0,0x0,0xbc,0x0,0x0,0x0,0x100000,0x200000,0x0,0x0,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x100000,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbc,0x0,0x0,0x0,0x1c3c700,0x0,0x0,0x0,0x0,0x0,0x1c3c700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x40,0x0,0x100000,0x0,0x0,0x1c3c700,0x2000000,0xbc,0x1c3c700,0x700,0x700,0x0,0x8000,0x38000,0x8000,0x0,0x3c000,0x1c00000,0x0,0x0,0x0,0x0,0x100000,0x100000,0x100000,0x100000,0x0,0x100000,0x100000,0x0,0x100000,0x100000,0x0,0x100000,0x40,0x40,0x0,0xbc,0x0,0x80000000,0x100,0x100,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbc,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x100000,0x1000bc,0x0,0x1000bc,0x0,0xbc,0x0,0x0,0xbc,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbc,};
   }
   private static void jj_la1_init_17() {
      jj_la1_17 = new int[] {0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x80000000,0x1,0x0,0x80000000,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x80000000,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x600,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fce,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x610,0x0,0x80000000,0x600,0x0,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x600,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x80000000,0x1,0x0,0x200,0x600,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fce,0x0,0x600,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_18() {
      jj_la1_18 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[45];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SqlParserImpl(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SqlParserImpl(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SqlParserImplTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 173; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 173; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SqlParserImpl(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SqlParserImplTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 173; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 173; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SqlParserImpl(SqlParserImplTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 173; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SqlParserImplTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 173; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[581];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 173; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
          if ((jj_la1_8[i] & (1<<j)) != 0) {
            la1tokens[256+j] = true;
          }
          if ((jj_la1_9[i] & (1<<j)) != 0) {
            la1tokens[288+j] = true;
          }
          if ((jj_la1_10[i] & (1<<j)) != 0) {
            la1tokens[320+j] = true;
          }
          if ((jj_la1_11[i] & (1<<j)) != 0) {
            la1tokens[352+j] = true;
          }
          if ((jj_la1_12[i] & (1<<j)) != 0) {
            la1tokens[384+j] = true;
          }
          if ((jj_la1_13[i] & (1<<j)) != 0) {
            la1tokens[416+j] = true;
          }
          if ((jj_la1_14[i] & (1<<j)) != 0) {
            la1tokens[448+j] = true;
          }
          if ((jj_la1_15[i] & (1<<j)) != 0) {
            la1tokens[480+j] = true;
          }
          if ((jj_la1_16[i] & (1<<j)) != 0) {
            la1tokens[512+j] = true;
          }
          if ((jj_la1_17[i] & (1<<j)) != 0) {
            la1tokens[544+j] = true;
          }
          if ((jj_la1_18[i] & (1<<j)) != 0) {
            la1tokens[576+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 581; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 45; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
